{
  "language": "Solidity",
  "sources": {
    "contracts/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev The implementation contract of Callers Authentication mechanism.\n * Ownable contract dependency used to setup a single owner who is deployer,\n * in order to prevent authorization rights abuse of one authority by another\n */\ncontract Auth is Ownable {\n    /**\n     * @dev Reverted if the caller is not authorized.\n     */\n    error CallerIsNotAuthorized();\n\n    /**\n     * @dev Emitted when the authorization status has been set.\n     */\n    event AuthorizationStatusChanged(address caller, bool status);\n\n    /**\n     * @dev Participations Mapping from NFT renter to Original NFT to Rental ID\n     */\n    mapping(address => bool) internal _authorizedCallers;\n\n    /**\n     * @dev Modifier to make a function callable only by the authorized callers.\n     */\n    modifier onlyAuthorizedCaller() {\n        if (!isAuthorizedCaller(msg.sender)) revert CallerIsNotAuthorized();\n        _;\n    }\n\n    /**\n     * @dev Updates authorization status for caller.\n     *      Can be changed only by Auth contract owner\n     * @param caller The caller address.\n     * @param status The caller authorization status.\n     */\n    function setAuthorizationStatus(address caller, bool status) external onlyOwner {\n        // Setting status for the caller\n        // true = authorized\n        // false = not authorized\n        _authorizedCallers[caller] = status;\n\n        emit AuthorizationStatusChanged(caller, status);\n    }\n\n    /**\n     * @dev Retrieve authorization status for caller.\n     * @param caller The caller address.\n     * @return Authorization status.\n     */\n    function isAuthorizedCaller(address caller) public view returns (bool) {\n        return _authorizedCallers[caller];\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/ERC20RewardWarper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@iqprotocol/solidity-contracts-nft/contracts/warper/ERC721/presets/ERC721PresetConfigurable.sol\";\n\nimport \"./interfaces/IERC20RewardDistributor.sol\";\nimport \"./interfaces/IRentingHookMechanics.sol\";\nimport \"./interfaces/IContractRegistry.sol\";\nimport \"./IERC20RewardWarper.sol\";\nimport \"./auth/Auth.sol\";\n\n/**\n * @title Custom Warper for ERC20 Tournament rewarding.\n */\ncontract ERC20RewardWarper is IERC20RewardWarper, IRentingHookMechanics, ERC721PresetConfigurable, Auth {\n    using IQProtocolStructsMock for IQProtocolStructsMock.RentalEarnings;\n    using IQProtocolStructsMock for IQProtocolStructsMock.Agreement;\n\n    /**\n     * @dev ERC20RewardDistributor contact key.\n     */\n    bytes4 private constant ERC20_REWARD_DISTRIBUTOR = bytes4(keccak256(\"ERC20RewardDistributor\"));\n\n    /**\n     * @dev ContractRegistry address.\n     */\n    address internal _contractRegistryMock;\n\n    /**\n     * @dev serviceId => tournamentId => player => tokenId => TournamentParticipant.\n     */\n    mapping(uint64 => mapping(uint64 => mapping(address => mapping(uint256 => TournamentParticipant))))\n        internal _tournamentParticipants;\n\n    /**\n     * @dev tokenId => rentalId.\n     */\n    mapping(address => mapping (uint256 => uint256)) internal _renterTokenIdsToRentals;\n\n    /**\n     * @dev rentalId => listingId.\n     */\n    mapping(uint256 => uint256) internal _rentalIdsToListings;\n\n    /**\n     * @dev Constructor for the IQNFTWarper contract.\n     */\n    constructor(bytes memory config) Auth() warperInitializer {\n        super.__initialize(config);\n    }\n\n    /**\n     * @inheritdoc IERC20RewardWarper\n     */\n    function distributeRewards(\n        uint64 serviceId,\n        uint64 tournamentId,\n        uint256 tokenId,\n        uint256 rewardAmount,\n        address participant,\n        address rewardTokenAddress\n    ) external onlyAuthorizedCaller {\n        // Retrieve participant record\n        TournamentParticipant memory tournamentParticipant = _tournamentParticipants[serviceId][tournamentId][\n            participant\n        ][tokenId];\n\n        // Check that participant exists\n        if (tournamentParticipant.listingId == 0 && tournamentParticipant.rentalId == 0) {\n            revert ParticipantDoesNotExist();\n        }\n\n        // Get address of ERC20RewardDistributor from Contract Registry\n        address rewardDistributor = IContractRegistry(_contractRegistryMock).getContract(ERC20_REWARD_DISTRIBUTOR);\n\n        // Init distribution through ERC20RewardDistributor\n        IQProtocolStructsMock.RentalEarnings memory rentalRewardFees = IERC20RewardDistributor(rewardDistributor)\n            .distributeExternalReward(\n                tournamentParticipant.listingId,\n                tournamentParticipant.rentalId,\n                rewardTokenAddress,\n                rewardAmount\n            );\n\n        // Emit event\n        // TODO review output for TRV needs.\n        emit RewardsDistributed(\n            serviceId,\n            tournamentId,\n            tokenId,\n            rewardAmount,\n            tournamentParticipant.rentalId,\n            tournamentParticipant.listingId,\n            participant,\n            rewardTokenAddress,\n            rentalRewardFees\n        );\n    }\n\n    /**\n     * @inheritdoc IERC20RewardWarper\n     */\n    function onJoinTournament(\n        uint64 serviceId,\n        uint64 tournamentId,\n        address participant,\n        uint256 tokenId\n    ) external onlyAuthorizedCaller {\n        // Make sure that the rental is active!\n        if (ownerOf(tokenId) != participant) revert ParticipantIsNotOwnerOfToken();\n\n        // Associate the rentalId with the participant in the tournament.\n        // We don't need to worry about the `_tokenIdsToRentals` being outdated\n        // because that's already implicitly checked via the ownerOf() call above.\n        uint256 rentalId = _renterTokenIdsToRentals[participant][tokenId];\n\n        // Retrieve listingId associated with the rentalId\n        uint256 listingId = _rentalIdsToListings[rentalId];\n\n        // Registering new tournament participant\n        _tournamentParticipants[serviceId][tournamentId][participant][tokenId] = TournamentParticipant({\n            rentalId: rentalId,\n            listingId: listingId\n        });\n\n        // Emit event\n        emit JoinedTournament(serviceId, tournamentId, participant, tokenId, rentalId);\n    }\n\n    /**\n     * @inheritdoc IRentingHookMechanics\n     */\n    function __onRent(\n        uint256 rentalId,\n        IQProtocolStructsMock.Agreement calldata rentalAgreement,\n        IQProtocolStructsMock.RentalEarnings calldata /* rentalEarnings */\n    ) external override onlyMetahub returns (bool, string memory) {\n        for (uint256 i = 0; i < rentalAgreement.warpedAssets.length; i++) {\n            (, uint256 tokenId) = _decodeAssetId(rentalAgreement.warpedAssets[i].id);\n            _renterTokenIdsToRentals[rentalAgreement.renter][tokenId] = rentalId;\n        }\n\n        _rentalIdsToListings[rentalId] = rentalAgreement.listingId;\n        // Inform Metahub that everything is fine\n        return (true, \"\");\n    }\n\n    /**\n     * @dev Retuns rental ID by token ID.\n     * @notice may be removed in future\n     * @param tokenId Token ID.\n     * @return Rental ID.\n     */\n    function getTokenRental(address renter, uint256 tokenId) external view returns(uint256) {\n        return _renterTokenIdsToRentals[renter][tokenId];\n    }\n\n    /**\n     * @dev Retuns listing ID by rental ID.\n     * @notice may be removed in future\n     * @param rentalId rental ID.\n     * @return Listing ID.\n     */\n    function getRentalListing(uint256 rentalId) external view returns(uint256) {\n        return _rentalIdsToListings[rentalId];\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IRentingHookMechanics).interfaceId ||\n            interfaceId == type(IERC20RewardWarper).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @notice TO REMOVE in future, was added because missing this method in current Warper implementation\n     * @dev Decodes asset ID and extracts identification data.\n     * @param id Asset ID structure.\n     * @return token Token contract address.\n     * @return tokenId Token ID.\n     */\n    function _decodeAssetId(Assets.AssetId memory id) internal pure returns (address token, uint256 tokenId) {\n        return abi.decode(id.data, (address, uint256));\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/ERC721/presets/ERC721PresetConfigurable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"../ERC721Warper.sol\";\nimport \"../../IWarperPreset.sol\";\nimport \"../../mechanics/availability-period/ConfigurableAvailabilityPeriodExtension.sol\";\nimport \"../../mechanics/rental-period/ConfigurableRentalPeriodExtension.sol\";\n\ncontract ERC721PresetConfigurable is\n    IWarperPreset,\n    ERC721Warper,\n    ConfigurableAvailabilityPeriodExtension,\n    ConfigurableRentalPeriodExtension\n{\n    /**\n     * @inheritdoc IWarperPreset\n     */\n    function __initialize(bytes memory config) public virtual warperInitializer {\n        // Decode config\n        (address original, address metahub) = abi.decode(config, (address, address));\n        _Warper_init(original, metahub);\n        _ConfigurableAvailabilityPeriodExtension_init();\n        _ConfigurableRentalPeriodExtension_init();\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721Warper, ConfigurableAvailabilityPeriodExtension, ConfigurableRentalPeriodExtension, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IWarperPreset).interfaceId ||\n            ERC721Warper.supportsInterface(interfaceId) ||\n            ConfigurableAvailabilityPeriodExtension.supportsInterface(interfaceId) ||\n            ConfigurableRentalPeriodExtension.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc ERC721Warper\n     */\n    function _validateOriginal(address original) internal virtual override(ERC721Warper, Warper) {\n        return ERC721Warper._validateOriginal(original);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20RewardDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../mocks/IQProtocolStructsMock.sol\";\n\ninterface IERC20RewardDistributor {\n    /**\n     * @dev Thrown when the Warper has not set enough allowance for ERC20RewardDistributor.\n     */\n    error InsufficientAllowanceForDistribution(uint256 asked, uint256 provided);\n\n    /**\n     * @dev External ERC20 Reward Fees coming from outside of protocol as a reward.\n     * @param token Address of reward token.\n     * @param totalReward Total amount of reward tokens.\n     * @param listerRewardFee Lister's part of reward tokens.\n     * @param renterRewardFee Renter's part of reward tokens.\n     * @param universeRewardFee Universe's part of reward tokens.\n     * @param protocolRewardFee Protocol's part of reward tokens.\n     */\n    struct RentalExternalERC20RewardFees {\n        address token;\n        uint256 totalReward;\n        uint256 listerRewardFee;\n        uint256 renterRewardFee;\n        uint256 universeRewardFee;\n        uint256 protocolRewardFee;\n    }\n\n    /**\n     * @notice Executes a single distribution of external ERC20 reward.\n     * @dev Before calling this function, an ERC20 increase allowance should be given\n     *  for the `tokenAmount` of `token`\n     *  by caller for Metahub.\n     * @param listingId The ID of related to the distribution Listing.\n     * @param agreementId The ID of related to the distribution Rental Agreement.\n     * @param token Represents the ERC20 token that is being distributed.\n     * @param rewardAmount Represents the `token` amount to be distributed as a reward.\n     * @return rentalExternalRewardEarnings Represents external reward based earnings for all entities.\n     */\n    function distributeExternalReward(\n        uint256 listingId,\n        uint256 agreementId,\n        address token,\n        uint256 rewardAmount\n    ) external returns (IQProtocolStructsMock.RentalEarnings memory rentalExternalRewardEarnings);\n}\n"
    },
    "contracts/interfaces/IRentingHookMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"../mocks/IQProtocolStructsMock.sol\";\n\ninterface IRentingHookMechanics {\n    /**\n     * @dev Thrown when the renting hook execution failed due to the `reason`.\n     */\n    error RentingHookError(string reason);\n\n    /**\n     * @dev Executes arbitrary logic after successful renting.\n     * NOTE: This function should not revert directly and must set correct `success` value instead.\n     *\n     * @param rentalId Rental agreement ID.\n     * @param rentalAgreement Newly registered rental agreement details.\n     * @param rentalEarnings The rental earnings breakdown.\n     * @return success True if hook was executed successfully.\n     * @return errorMessage The reason of the hook execution failure.\n     */\n    function __onRent(\n        uint256 rentalId,\n        IQProtocolStructsMock.Agreement calldata rentalAgreement,\n        IQProtocolStructsMock.RentalEarnings calldata rentalEarnings\n    ) external returns (bool success, string memory errorMessage);\n}\n"
    },
    "contracts/interfaces/IContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ninterface IContractRegistry {\n    /**\n     * @dev Thrown when the contract with a provided key does not exist.\n     */\n    error InvalidContractEntityInterface();\n\n    /**\n     * @dev Thrown when the contract with a provided key does not exist.\n     */\n    error ContractKeyMismatch(bytes4 keyProvided, bytes4 keyRequired);\n\n    /**\n     * @dev Thrown when the contract with a provided key does not exist.\n     */\n    error ContractNotAuthorized(bytes4 keyProvided, address addressProvided);\n\n    /**\n     * @dev Thrown when the contract with a provided key does not exist.\n     */\n    error ContractDoesNotExist(bytes4 keyProvided);\n\n    /**\n     * @dev Emitted when the new contract is registered.\n     * @param contractKey Key of the contract.\n     * @param contractAddress Address of the contract.\n     */\n    event ContractRegistered(bytes4 contractKey, address contractAddress);\n\n    /**\n     * @dev Register new contract with a key.\n     * @param contractKey Key of the contract.\n     * @param contractAddress Address of the contract.\n     */\n    function registerContract(bytes4 contractKey, address contractAddress) external;\n\n    /**\n     * @dev Get contract address with a key.\n     * @param contractKey Key of the contract.\n     * @return Contract address.\n     */\n    function getContract(bytes4 contractKey) external view returns (address);\n}\n"
    },
    "contracts/IERC20RewardWarper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"./mocks/IQProtocolStructsMock.sol\";\n\ninterface IERC20RewardWarper {\n    /**\n     * @dev Thrown when the participant does not exist.\n     */\n    error ParticipantDoesNotExist();\n\n    /**\n     * @dev Thrown when the participant address does not match the owners address of the token!\n     */\n    error ParticipantIsNotOwnerOfToken();\n\n    /**\n     * @dev Emitted when a user has joined the tournament.\n     */\n    event JoinedTournament(\n        uint64 serviceId,\n        uint64 tournamentId,\n        address participant,\n        uint256 tokenId,\n        uint256 rentalId\n    );\n\n    event RewardsDistributed(\n        uint64 serviceId,\n        uint64 tournamentId,\n        uint256 tokenId,\n        uint256 rewardAmount,\n        uint256 rentalId,\n        uint256 listingId,\n        address participant,\n        address rewardTokenAddress,\n        IQProtocolStructsMock.RentalEarnings tournamentEarnings\n    );\n\n    /**\n     * @dev Tournament participant data.\n     * @param rentalId Rental agreement ID.\n     * @param listingId Listing ID.\n     */\n    struct TournamentParticipant {\n        uint256 rentalId;\n        uint256 listingId;\n    }\n\n    /**\n     * @dev Executes tournament reward distribution logic after successful setWinner() execution on TRV contract.\n     * @param serviceId represents the TRV service ID.\n     * @param tournamentId represents the tournament ID.\n     * @param tokenId The token ID.\n     * @param rewardAmount The reward tokens amount.\n     * @param participant The address of the player.\n     * @param rewardTokenAddress The reward IERC20 token contract address.\n     */\n    function distributeRewards(\n        uint64 serviceId,\n        uint64 tournamentId,\n        uint256 tokenId,\n        uint256 rewardAmount,\n        address participant,\n        address rewardTokenAddress\n    ) external;\n\n    /**\n     * @dev Must be called when a user joins the tournament with a warped asset.\n     * @param serviceId represents the TRV service ID.\n     * @param tournamentId represents the tournament ID.\n     * @param participant The address of the player.\n     * @param tokenId The token id of the warped asset.\n     */\n    function onJoinTournament(\n        uint64 serviceId,\n        uint64 tournamentId,\n        address participant,\n        uint256 tokenId\n    ) external;\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/ERC721/ERC721Warper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable ordering\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"../../metahub/IMetahub.sol\";\nimport \"../../renting/Rentings.sol\";\nimport \"../Warper.sol\";\nimport \"./IERC721Warper.sol\";\nimport \"./IERC721WarperController.sol\";\n\n/**\n * @title Warper for the ERC721 token contract\n */\nabstract contract ERC721Warper is IERC721Warper, Warper {\n    using ERC165Checker for address;\n    using Address for address;\n\n    /**\n     * @dev Mapping from token ID to owner address\n     */\n    mapping(uint256 => address) private _owners;\n\n    /**\n     * @inheritdoc IWarper\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    function __assetClass() external pure returns (bytes4) {\n        return Assets.ERC721;\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev Method is disabled, kept only for interface compatibility purposes.\n     */\n    function setApprovalForAll(address, bool) external virtual {\n        revert MethodNotAllowed();\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev Method is disabled, kept only for interface compatibility purposes.\n     */\n    function approve(address, uint256) external virtual {\n        revert MethodNotAllowed();\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - needs to pass validation of `_beforeTokenTransfer()`.\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function mint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external {\n        if (to == address(0)) revert MintToTheZeroAddress();\n        if (_exists(tokenId)) revert TokenIsAlreadyMinted(tokenId);\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {\n            revert TransferToNonERC721ReceiverImplementer(to);\n        }\n    }\n\n    /**\n     * @inheritdoc IERC721\n     *\n     * @dev Need to fulfill all the requirements of `_transfer()`\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     *\n     * @dev Need to fulfill all the requirements of `_transfer()`\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @inheritdoc IERC721\n     *\n     * @dev Need to fulfill all the requirements of `_transfer()`\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public {\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721Warper).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev The rental count calculations get offloaded to the Metahub\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        IERC721WarperController warperController = _warperController();\n        return warperController.rentalBalance(_metahub(), address(this), owner);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev The ownership is dependant on the rental status - metahub is\n     *      responsible for tracking the state:\n     *          - NONE: revert with an error\n     *          - AVAILABLE: means, that the token is not currently rented. Metahub is the owner.\n     *          - RENTED: Use the Warpers internal ownership constructs\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        // Special rent-sate handling\n        {\n            Rentings.RentalStatus rentalStatus = _getWarperRentalStatus(tokenId);\n\n            if (rentalStatus == Rentings.RentalStatus.NONE) revert OwnerQueryForNonexistentToken(tokenId);\n            if (rentalStatus == Rentings.RentalStatus.AVAILABLE) return _metahub();\n        }\n\n        // `rentalStatus` is now RENTED\n        // Fallback to using the internal owner tracker\n        address owner = _owners[tokenId];\n        if (owner == address(0)) revert OwnerQueryForNonexistentToken(tokenId);\n\n        return owner;\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        Rentings.RentalStatus rentalStatus = _getWarperRentalStatus(tokenId);\n        if (rentalStatus == Rentings.RentalStatus.NONE) revert OwnerQueryForNonexistentToken(tokenId);\n\n        return _metahub();\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(address, address operator) public view returns (bool) {\n        return operator == _metahub();\n    }\n\n    /**\n     * @dev Validates the original NFT.\n     */\n    function _validateOriginal(address original) internal virtual override {\n        if (!original.supportsInterface(type(IERC721Metadata).interfaceId)) {\n            revert InvalidOriginalTokenInterface(original, type(IERC721Metadata).interfaceId);\n        }\n        super._validateOriginal(original);\n    }\n\n    /**\n     * @dev ONLY THE METAHUB CAN CALL THIS METHOD.\n     *      This validates every single transfer that the warper can perform.\n     *      Metahub can be the only source of transfers, so it can properly synchronise\n     *      the rental agreement ownership.\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal onlyMetahub {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - Needs to fulfill all the requirements of `_transfer()`\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\n            revert TransferToNonERC721ReceiverImplementer(to);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - needs to pass validation of `_beforeTokenTransfer()`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        if (!_exists(tokenId)) revert OperatorQueryForNonexistentToken(tokenId);\n        if (to == address(0)) revert TransferToTheZeroAddress();\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Get the associated warper controller.\n     */\n    function _warperController() internal view returns (IERC721WarperController) {\n        return IERC721WarperController(IMetahub(_metahub()).warperController(address(this)));\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (!to.isContract()) return true;\n\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 result) {\n            return result == IERC721Receiver.onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer(to);\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get the rental status of a token.\n     */\n    function _getWarperRentalStatus(uint256 tokenId) private view returns (Rentings.RentalStatus) {\n        IERC721WarperController warperController = _warperController();\n        return warperController.rentalStatus(_metahub(), address(this), tokenId);\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/IWarperPreset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"./IWarper.sol\";\n\ninterface IWarperPreset is IWarper {\n    /**\n     * @dev Warper generic initialization method.\n     * @param config Warper configuration parameters.\n     */\n    function __initialize(bytes calldata config) external;\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/mechanics/availability-period/ConfigurableAvailabilityPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase, ordering\npragma solidity ^0.8.13;\n\nimport \"../../Warper.sol\";\nimport \"./IConfigurableAvailabilityPeriodExtension.sol\";\n\nabstract contract ConfigurableAvailabilityPeriodExtension is IConfigurableAvailabilityPeriodExtension, Warper {\n    /**\n     * @dev Warper availability period.\n     */\n    bytes32 private constant _AVAILABILITY_PERIOD_SLOT =\n        bytes32(uint256(keccak256(\"iq.warper.params.availabilityPeriod\")) - 1);\n\n    uint256 private constant _MAX_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\n    uint256 private constant _MIN_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFF;\n    uint256 private constant _MAX_PERIOD_BITSHIFT = 0;\n    uint256 private constant _MIN_PERIOD_BITSHIFT = 32;\n\n    /**\n     * Extension initializer.\n     */\n    function _ConfigurableAvailabilityPeriodExtension_init() internal onlyInitializingWarper {\n        _setAvailabilityPeriods(0, type(uint32).max);\n    }\n\n    /**\n     * @inheritdoc IConfigurableAvailabilityPeriodExtension\n     */\n    function __setAvailabilityPeriodStart(uint32 availabilityPeriodStart) external virtual onlyWarperAdmin {\n        (, uint32 availabilityPeriodEnd) = _availabilityPeriods();\n        if (availabilityPeriodStart >= availabilityPeriodEnd) revert InvalidAvailabilityPeriodStart();\n\n        _setAvailabilityPeriods(availabilityPeriodStart, availabilityPeriodEnd);\n    }\n\n    /**\n     * @inheritdoc IConfigurableAvailabilityPeriodExtension\n     */\n    function __setAvailabilityPeriodEnd(uint32 availabilityPeriodEnd) external virtual onlyWarperAdmin {\n        (uint32 availabilityPeriodStart, ) = _availabilityPeriods();\n        if (availabilityPeriodStart >= availabilityPeriodEnd) revert InvalidAvailabilityPeriodEnd();\n\n        _setAvailabilityPeriods(availabilityPeriodStart, availabilityPeriodEnd);\n    }\n\n    /**\n     * @inheritdoc IAvailabilityPeriodMechanics\n     */\n    function __availabilityPeriodStart() external view virtual returns (uint32) {\n        (uint32 availabilityPeriodStart, ) = _availabilityPeriods();\n        return availabilityPeriodStart;\n    }\n\n    /**\n     * @inheritdoc IAvailabilityPeriodMechanics\n     */\n    function __availabilityPeriodEnd() external view virtual returns (uint32) {\n        (, uint32 availabilityPeriodEnd) = _availabilityPeriods();\n        return availabilityPeriodEnd;\n    }\n\n    /**\n     * @inheritdoc IAvailabilityPeriodMechanics\n     */\n    function __availabilityPeriodRange()\n        external\n        view\n        virtual\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd)\n    {\n        (availabilityPeriodStart, availabilityPeriodEnd) = _availabilityPeriods();\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper) returns (bool) {\n        return\n            interfaceId == type(IConfigurableAvailabilityPeriodExtension).interfaceId ||\n            interfaceId == type(IAvailabilityPeriodMechanics).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Stores warper availability period.\n     */\n    function _setAvailabilityPeriods(uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd) internal {\n        uint256 data = (0 & _MAX_PERIOD_MASK) | (uint256(availabilityPeriodEnd) << _MAX_PERIOD_BITSHIFT);\n        data = (data & _MIN_PERIOD_MASK) | (uint256(availabilityPeriodStart) << _MIN_PERIOD_BITSHIFT);\n\n        StorageSlot.getUint256Slot(_AVAILABILITY_PERIOD_SLOT).value = data;\n    }\n\n    /**\n     * @dev Returns warper availability period.\n     */\n    function _availabilityPeriods()\n        internal\n        view\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd)\n    {\n        uint256 data = StorageSlot.getUint256Slot(_AVAILABILITY_PERIOD_SLOT).value;\n        availabilityPeriodStart = uint32((data & ~_MIN_PERIOD_MASK) >> _MIN_PERIOD_BITSHIFT);\n        availabilityPeriodEnd = uint32((data & ~_MAX_PERIOD_MASK) >> _MAX_PERIOD_BITSHIFT);\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/mechanics/rental-period/ConfigurableRentalPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase, ordering\npragma solidity ^0.8.13;\n\nimport \"../../Warper.sol\";\nimport \"./IConfigurableRentalPeriodExtension.sol\";\n\nabstract contract ConfigurableRentalPeriodExtension is IConfigurableRentalPeriodExtension, Warper {\n    /**\n     * @dev Warper rental period.\n     * @dev It contains both - the min and max values (uint32) - in a concatenated form.\n     */\n    bytes32 private constant _RENTAL_PERIOD_SLOT = bytes32(uint256(keccak256(\"iq.warper.params.rentalPeriod\")) - 1);\n\n    uint256 private constant _MAX_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\n    uint256 private constant _MIN_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFF;\n    uint256 private constant _MAX_PERIOD_BITSHIFT = 0;\n    uint256 private constant _MIN_PERIOD_BITSHIFT = 32;\n\n    /**\n     * @dev Extension initializer.\n     */\n    function _ConfigurableRentalPeriodExtension_init() internal onlyInitializingWarper {\n        // Store default values.\n        _setRentalPeriods(0, type(uint32).max);\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper) returns (bool) {\n        return\n            interfaceId == type(IConfigurableRentalPeriodExtension).interfaceId ||\n            interfaceId == type(IRentalPeriodMechanics).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IConfigurableRentalPeriodExtension\n     */\n    function __setMinRentalPeriod(uint32 minRentalPeriod) external virtual onlyWarperAdmin {\n        (, uint32 maxRentalPeriod) = _rentalPeriods();\n        if (minRentalPeriod > maxRentalPeriod) revert InvalidMinRentalPeriod();\n\n        _setRentalPeriods(minRentalPeriod, maxRentalPeriod);\n    }\n\n    /**\n     * @inheritdoc IConfigurableRentalPeriodExtension\n     */\n    function __setMaxRentalPeriod(uint32 maxRentalPeriod) external virtual onlyWarperAdmin {\n        (uint32 minRentalPeriod, ) = _rentalPeriods();\n        if (minRentalPeriod > maxRentalPeriod) revert InvalidMaxRentalPeriod();\n\n        _setRentalPeriods(minRentalPeriod, maxRentalPeriod);\n    }\n\n    /**\n     * @inheritdoc IRentalPeriodMechanics\n     */\n    function __minRentalPeriod() external view virtual returns (uint32) {\n        (uint32 minRentalPeriod, ) = _rentalPeriods();\n        return minRentalPeriod;\n    }\n\n    /**\n     * @inheritdoc IRentalPeriodMechanics\n     */\n    function __maxRentalPeriod() external view virtual override returns (uint32) {\n        (, uint32 maxRentalPeriod) = _rentalPeriods();\n        return maxRentalPeriod;\n    }\n\n    /**\n     * @inheritdoc IRentalPeriodMechanics\n     */\n    function __rentalPeriodRange() external view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod) {\n        (minRentalPeriod, maxRentalPeriod) = _rentalPeriods();\n    }\n\n    /**\n     * @dev Stores warper rental period.\n     */\n    function _setRentalPeriods(uint32 minRentalPeriod, uint32 maxRentalPeriod) internal {\n        uint256 data = (0 & _MAX_PERIOD_MASK) | (uint256(maxRentalPeriod) << _MAX_PERIOD_BITSHIFT);\n        data = (data & _MIN_PERIOD_MASK) | (uint256(minRentalPeriod) << _MIN_PERIOD_BITSHIFT);\n\n        StorageSlot.getUint256Slot(_RENTAL_PERIOD_SLOT).value = data;\n    }\n\n    /**\n     * @dev Returns warper rental periods.\n     */\n    function _rentalPeriods() internal view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod) {\n        uint256 data = StorageSlot.getUint256Slot(_RENTAL_PERIOD_SLOT).value;\n        minRentalPeriod = uint32((data & ~_MIN_PERIOD_MASK) >> _MIN_PERIOD_BITSHIFT);\n        maxRentalPeriod = uint32((data & ~_MAX_PERIOD_MASK) >> _MAX_PERIOD_BITSHIFT);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Receiver.sol\";\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/metahub/IMetahub.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-empty-blocks\npragma solidity ^0.8.13;\n\nimport \"../accounting/IPaymentManager.sol\";\nimport \"../listing/IListingManager.sol\";\nimport \"../renting/IRentingManager.sol\";\nimport \"../asset/IAssetManager.sol\";\nimport \"./IProtocolConfigManager.sol\";\n\ninterface IMetahub is IProtocolConfigManager, IPaymentManager, IListingManager, IRentingManager, IAssetManager {}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/renting/Rentings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../asset/Assets.sol\";\nimport \"../metahub/Protocol.sol\";\nimport \"../listing/Listings.sol\";\nimport \"../warper/Warpers.sol\";\nimport \"../universe/IUniverseRegistry.sol\";\n\nlibrary Rentings {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using Rentings for RenterInfo;\n    using Rentings for Agreement;\n    using Rentings for Registry;\n    using Assets for Assets.AssetId;\n    using Protocol for Protocol.Config;\n    using Listings for Listings.Registry;\n    using Listings for Listings.Listing;\n    using Warpers for Warpers.Registry;\n    using Warpers for Warpers.Warper;\n\n    /**\n     * A constant that represents one hundred percent for calculation.\n     * This defines a calculation precision for percentage values as two decimals.\n     * For example: 1 is 0.01%, 100 is 1%, 10_000 is 100%.\n     */\n    uint16 public constant HUNDRED_PERCENT = 10_000;\n\n    /**\n     * @dev Thrown when a rental agreement is being registered for a specific warper ID,\n     * while the previous rental agreement for this warper is still effective.\n     */\n    error RentalAgreementConflict(uint256 conflictingRentalId);\n\n    /**\n     * @dev Thrown when attempting to delete effective rental agreement data (before expiration).\n     */\n    error CannotDeleteEffectiveRentalAgreement(uint256 rentalId);\n\n    /**\n     * @dev Warper rental status.\n     * NONE - means the warper had never been minted.\n     * AVAILABLE - can be rented.\n     * RENTED - currently rented.\n     */\n    enum RentalStatus {\n        NONE,\n        AVAILABLE,\n        RENTED\n    }\n\n    /**\n     * @dev Defines the maximal allowed number of cycles when looking for expired rental agreements.\n     */\n    uint256 private constant _GC_CYCLES = 20;\n\n    /**\n     * @dev Rental fee breakdown.\n     */\n    struct RentalFees {\n        uint256 total;\n        uint256 protocolFee;\n        uint256 listerBaseFee;\n        uint256 listerPremium;\n        uint256 universeBaseFee;\n        uint256 universePremium;\n    }\n\n    /**\n     * @dev Renting parameters structure.\n     * It is used to encode all the necessary information to estimate and/or fulfill a particular renting request.\n     * @param listingId Listing ID. Also allows to identify the asset being rented.\n     * @param warper Warper address.\n     * @param renter Renter address.\n     * @param rentalPeriod Desired period of asset renting.\n     * @param paymentToken The token address which renter offers as a mean of payment.\n     */\n    struct Params {\n        uint256 listingId;\n        address warper;\n        address renter;\n        uint32 rentalPeriod;\n        address paymentToken;\n    }\n\n    /**\n     * @dev Rental agreement information.\n     * @param warpedAsset Rented asset.\n     * @param collectionId Warped collection ID.\n     * @param listingId The corresponding ID of the original asset listing.\n     * @param renter The renter account address.\n     * @param startTime The rental agreement staring time. This is the timestamp after which the `renter`\n     * considered to be an warped asset owner.\n     * @param endTime The rental agreement ending time. After this timestamp, the rental agreement is terminated\n     * and the `renter` is no longer the owner of the warped asset.\n     * @param listingParams Selected listing parameters.\n     */\n    struct Agreement {\n        // slots 0-2\n        Assets.Asset warpedAsset;\n        // slot 3\n        bytes32 collectionId;\n        // slot 4\n        uint256 listingId;\n        // slot 5 (4 bytes left)\n        address renter;\n        uint32 startTime;\n        uint32 endTime;\n        // slots 6-7\n        Listings.Params listingParams;\n    }\n\n    function isEffective(Agreement storage self) internal view returns (bool) {\n        return self.endTime > uint32(block.timestamp);\n    }\n\n    function duration(Agreement memory self) internal pure returns (uint32) {\n        return self.endTime - self.startTime;\n    }\n\n    /**\n     * @dev Describes user specific renting information.\n     * @param rentalIndex Renter's set of rental agreement IDs.\n     * @param collectionRentalIndex Mapping from collection ID to the set of rental IDs.\n     */\n    struct RenterInfo {\n        EnumerableSetUpgradeable.UintSet rentalIndex;\n        mapping(bytes32 => EnumerableSetUpgradeable.UintSet) collectionRentalIndex;\n    }\n\n    /**\n     * @dev Describes asset specific renting information.\n     * @param latestRentalId Holds the most recent rental agreement ID.\n     */\n    struct AssetInfo {\n        uint256 latestRentalId; // NOTE: This must never be deleted during cleanup.\n    }\n\n    /**\n     * @dev Renting registry.\n     * @param idTracker Rental agreement ID tracker (incremental counter).\n     * @param agreements Mapping from rental ID to the rental agreement details.\n     * @param renters Mapping from renter address to the user specific renting info.\n     * @param assets Mapping from asset ID (byte32) to the asset specific renting info.\n     */\n    struct Registry {\n        CountersUpgradeable.Counter idTracker;\n        mapping(uint256 => Agreement) agreements;\n        mapping(address => RenterInfo) renters;\n        mapping(bytes32 => AssetInfo) assets;\n    }\n\n    /**\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\n     */\n    function userRentalCount(Registry storage self, address renter) internal view returns (uint256) {\n        return self.renters[renter].rentalIndex.length();\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\n     */\n    function userRentalAgreements(\n        Registry storage self,\n        address renter,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory) {\n        EnumerableSetUpgradeable.UintSet storage userRentalIndex = self.renters[renter].rentalIndex;\n        uint256 indexSize = userRentalIndex.length();\n        if (offset >= indexSize) return (new uint256[](0), new Rentings.Agreement[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        Rentings.Agreement[] memory agreements = new Rentings.Agreement[](limit);\n        uint256[] memory rentalIds = new uint256[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            rentalIds[i] = userRentalIndex.at(offset + i);\n            agreements[i] = self.agreements[rentalIds[i]];\n        }\n\n        return (rentalIds, agreements);\n    }\n\n    /**\n     * @dev Finds expired user rental agreements associated with `collectionId` and deletes them.\n     * Deletes only first N entries defined by `toBeRemoved` param.\n     * The total number of cycles is capped by GC_CYCLES constant.\n     */\n    function deleteExpiredUserRentalAgreements(\n        Registry storage self,\n        address renter,\n        bytes32 collectionId,\n        uint256 toBeRemoved\n    ) external {\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\n        uint256 rentalCount = rentalIndex.length();\n        if (rentalCount == 0 || toBeRemoved == 0) return;\n\n        uint256 maxCycles = rentalCount < _GC_CYCLES ? rentalCount : _GC_CYCLES;\n        uint256 removed = 0;\n\n        for (uint256 i = 0; i < maxCycles; i++) {\n            uint256 rentalId = rentalIndex.at(i);\n\n            if (!self.agreements[rentalId].isEffective()) {\n                // Warning: we are iterating an array that we are also modifying!\n                _removeRentalAgreement(self, rentalId);\n                removed += 1;\n                maxCycles -= 1; // This is so we account for reduced `rentalCount`.\n\n                // Stop iterating if we have cleaned up enough desired items.\n                if (removed == toBeRemoved) break;\n            }\n        }\n    }\n\n    /**\n     * @dev Performs new rental agreement registration.\n     */\n    function register(Registry storage self, Agreement memory agreement) external returns (uint256 rentalId) {\n        // Make sure the there is no active rentals for the warper ID.\n        bytes32 assetId = agreement.warpedAsset.id.hash();\n        uint256 latestRentalId = self.assets[assetId].latestRentalId;\n        if (latestRentalId != 0 && self.agreements[latestRentalId].isEffective()) {\n            revert RentalAgreementConflict(latestRentalId);\n        }\n\n        // Generate new rental ID.\n        self.idTracker.increment();\n        rentalId = self.idTracker.current();\n\n        // Save new rental agreement.\n        self.agreements[rentalId] = agreement;\n\n        // Update warper latest rental ID.\n        self.assets[assetId].latestRentalId = rentalId;\n\n        // Update user rental data.\n        self.renters[agreement.renter].rentalIndex.add(rentalId);\n        self.renters[agreement.renter].collectionRentalIndex[agreement.collectionId].add(rentalId);\n    }\n\n    /**\n     * @dev Safely removes expired rental data from the registry.\n     */\n    function removeExpiredRentalAgreement(Registry storage self, uint256 rentalId) external {\n        if (self.agreements[rentalId].isEffective()) revert CannotDeleteEffectiveRentalAgreement(rentalId);\n        _removeRentalAgreement(self, rentalId);\n    }\n\n    /**\n     * @dev Removes rental data from the registry.\n     */\n    function _removeRentalAgreement(Registry storage self, uint256 rentalId) private {\n        address renter = self.agreements[rentalId].renter;\n        bytes32 collectionId = self.agreements[rentalId].collectionId;\n\n        // Remove user rental data.\n        self.renters[renter].rentalIndex.remove(rentalId);\n        self.renters[renter].collectionRentalIndex[collectionId].remove(rentalId);\n\n        // Delete rental agreement.\n        delete self.agreements[rentalId];\n    }\n\n    /**\n     * @dev Finds all effective rental agreements from specific collection.\n     * Returns the total value rented by `renter`.\n     */\n    function collectionRentedValue(\n        Registry storage self,\n        address renter,\n        bytes32 collectionId\n    ) external view returns (uint256 value) {\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\n        uint256 length = rentalIndex.length();\n        for (uint256 i = 0; i < length; i++) {\n            Agreement storage agreement = self.agreements[rentalIndex.at(i)];\n            if (agreement.isEffective()) {\n                value += agreement.warpedAsset.value;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns asset rental status based on latest rental agreement.\n     */\n    function assetRentalStatus(Registry storage self, Assets.AssetId memory assetId)\n        external\n        view\n        returns (RentalStatus)\n    {\n        uint256 latestRentalId = self.assets[assetId.hash()].latestRentalId;\n        if (latestRentalId == 0) return RentalStatus.NONE;\n\n        return self.agreements[latestRentalId].isEffective() ? RentalStatus.RENTED : RentalStatus.AVAILABLE;\n    }\n\n    /**\n     * @dev Main renting request validation function.\n     */\n    function validateRentingParams(\n        Params calldata params,\n        Protocol.Config storage protocolConfig,\n        Listings.Registry storage listingRegistry,\n        IWarperManager warperManager\n    ) external view {\n        // Validate from the protocol perspective.\n        protocolConfig.checkBaseToken(params.paymentToken);\n\n        // Validate from the listing perspective.\n        listingRegistry.checkListed(params.listingId);\n        Listings.Listing storage listing = listingRegistry.listings[params.listingId];\n        listing.checkNotPaused();\n        listing.checkValidLockPeriod(params.rentalPeriod);\n\n        // Validate from the warper perspective.\n        warperManager.checkRegisteredWarper(params.warper);\n        Warpers.Warper memory warper = warperManager.warperInfo(params.warper);\n        warper.checkCompatibleAsset(listing.asset);\n        warper.checkNotPaused();\n        warper.controller.validateRentingParams(listing.asset, params);\n    }\n\n    /**\n     * @dev Performs rental fee calculation and returns the fee breakdown.\n     */\n    function calculateRentalFees(\n        Params calldata rentingParams,\n        Protocol.Config storage protocolConfig,\n        Listings.Registry storage listingRegistry,\n        IWarperManager warperManager,\n        IUniverseRegistry universeRegistry\n    ) external view returns (RentalFees memory fees) {\n        // Calculate lister base fee.\n        Listings.Listing storage listing = listingRegistry.listings[rentingParams.listingId];\n        Listings.Params memory listingParams = listing.params;\n        // Resolve listing controller to calculate lister fee based on selected listing strategy.\n        IListingController listingController = listingRegistry.listingController(listingParams.strategy);\n        fees.listerBaseFee = listingController.calculateRentalFee(listingParams, rentingParams);\n\n        // Calculate universe base fee.\n        Warpers.Warper memory warper = warperManager.warperInfo(rentingParams.warper);\n        uint16 universeRentalFeePercent = universeRegistry.universeRentalFeePercent(warper.universeId);\n        fees.universeBaseFee = (fees.listerBaseFee * universeRentalFeePercent) / HUNDRED_PERCENT;\n\n        // Calculate protocol fee.\n        fees.protocolFee = (fees.listerBaseFee * protocolConfig.rentalFeePercent) / HUNDRED_PERCENT;\n\n        // Calculate warper premiums.\n        (uint256 universePremium, uint256 listerPremium) = warper.controller.calculatePremiums(\n            listing.asset,\n            rentingParams,\n            fees.universeBaseFee,\n            fees.listerBaseFee\n        );\n        fees.listerPremium = listerPremium;\n        fees.universePremium = universePremium;\n\n        // Calculate TOTAL rental fee.\n        fees.total += fees.listerBaseFee + listerPremium;\n        fees.total += fees.universeBaseFee + universePremium;\n        fees.total += fees.protocolFee;\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/Warper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"./IWarper.sol\";\nimport \"./utils/CallForwarder.sol\";\nimport \"./utils/WarperContext.sol\";\n\nabstract contract Warper is IWarper, WarperContext, CallForwarder, Multicall {\n    using ERC165Checker for address;\n\n    /**\n     * @dev Thrown when the original asset contract does not implement the interface, expected by Warper.\n     */\n    error InvalidOriginalTokenInterface(address original, bytes4 requiredInterfaceId);\n\n    /**\n     * @dev Forwards the current call to the original asset contract. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Forwards the current call to the original asset contract`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Warper initializer.\n     *\n     */\n    function _Warper_init(address original, address metahub) internal onlyInitializingWarper {\n        _validateOriginal(original);\n        _setOriginal(original);\n        _setMetahub(metahub);\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165) returns (bool) {\n        return\n            interfaceId == type(IWarper).interfaceId ||\n            interfaceId == type(IERC165).interfaceId ||\n            _original().supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IWarper\n     */\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory) {\n        return address(this).getSupportedInterfaces(interfaceIds);\n    }\n\n    /**\n     * @dev Returns the original NFT address.\n     */\n    function __original() external view returns (address) {\n        return _original();\n    }\n\n    /**\n     * @inheritdoc IWarper\n     */\n    function __metahub() external view returns (address) {\n        return _metahub();\n    }\n\n    /**\n     * @dev Forwards the current call to the original asset contract`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _forward(_original());\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the original. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Validates the original NFT.\n     *\n     * If overridden should call `super._validateOriginal()`.\n     */\n    function _validateOriginal(address original) internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/ERC721/IERC721Warper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"../IWarper.sol\";\n\ninterface IERC721Warper is IWarper, IERC721 {\n    /**\n     * @dev Thrown when querying token balance for address(0)\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * @dev Thrown when querying for the owner of a token that has not been minted yet.\n     */\n    error OwnerQueryForNonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Thrown when querying for the operator of a token that has not been minted yet.\n     */\n    error OperatorQueryForNonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Thrown when attempting to safeTransfer to a contract that cannot handle ERC721 tokens.\n     */\n    error TransferToNonERC721ReceiverImplementer(address to);\n\n    /**\n     * @dev Thrown when minting to the address(0).\n     */\n    error MintToTheZeroAddress();\n\n    /**\n     * @dev Thrown when minting a token that already exists.\n     */\n    error TokenIsAlreadyMinted(uint256 tokenId);\n\n    /**\n     * @dev Thrown transferring a token to the address(0).\n     */\n    error TransferToTheZeroAddress();\n\n    /**\n     * @dev Thrown when calling a method that has been purposely disabled.\n     */\n    error MethodNotAllowed();\n\n    /**\n     * @dev Mint new tokens.\n     * @param to The address to mint the token to.\n     * @param tokenId The ID of the token to mint.\n     * @param data The data to send over to the receiver if it supports `onERC721Received` hook.\n     */\n    function mint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external;\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/ERC721/IERC721WarperController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../IWarperController.sol\";\nimport \"../../asset/Assets.sol\";\n\ninterface IERC721WarperController is IWarperController {\n    /**\n     * @dev Get the active rental balance for a given warper and a renter.\n     *      Used in Warper->Metahub communication.\n     * @param metahub Address of the metahub.\n     * @param warper Address of the warper.\n     * @param renter Address of the renter whose active rental counts we need to fetch.\n     */\n    function rentalBalance(\n        address metahub,\n        address warper,\n        address renter\n    ) external view returns (uint256);\n\n    /**\n     * @dev Get the rental status of a specific token.\n     *      Used in Warper->Metahub communication.\n     * @param metahub Address of the metahub.\n     * @param warper Address of the warper.\n     * @param tokenId The token ID to be checked for status.\n     */\n    function rentalStatus(\n        address metahub,\n        address warper,\n        uint256 tokenId\n    ) external view returns (Rentings.RentalStatus);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/accounting/IPaymentManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Accounts.sol\";\n\ninterface IPaymentManager {\n    /**\n     * @notice Describes the earning type.\n     */\n    enum EarningType {\n        LISTER_FEE\n    }\n\n    /**\n     * @dev Emitted when a user has earned some amount tokens.\n     * @param user Address of the user that earned some amount.\n     * @param earningType Describes the type of the user.\n     * @param paymentToken The currency that the user has earned.\n     * @param amount The amount of tokens that the user has earned.\n     */\n    event UserEarned(\n        address indexed user,\n        EarningType indexed earningType,\n        address indexed paymentToken,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when the universe has earned some amount of tokens.\n     * @param universeId ID of the universe that earned the tokens.\n     * @param paymentToken The currency that the user has earned.\n     * @param amount The amount of tokens that the user has earned.\n     */\n    event UniverseEarned(uint256 indexed universeId, address indexed paymentToken, uint256 amount);\n\n    /**\n     * @dev Emitted when the protocol has earned some amount of tokens.\n     * @param paymentToken The currency that the user has earned.\n     * @param amount The amount of tokens that the user has earned.\n     */\n    event ProtocolEarned(address indexed paymentToken, uint256 amount);\n\n    /**\n     * @dev Transfers the specific `amount` of `token` from a protocol balance to an arbitrary address.\n     * @param token The token address.\n     * @param amount The amount to be withdrawn.\n     * @param to The payee address.\n     */\n    function withdrawProtocolFunds(\n        address token,\n        uint256 amount,\n        address to\n    ) external;\n\n    /**\n     * @dev Transfers the specific `amount` of `token` from a universe balance to an arbitrary address.\n     * @param universeId The universe ID.\n     * @param token The token address.\n     * @param amount The amount to be withdrawn.\n     * @param to The payee address.\n     */\n    function withdrawUniverseFunds(\n        uint256 universeId,\n        address token,\n        uint256 amount,\n        address to\n    ) external;\n\n    /**\n     * @dev Transfers the specific `amount` of `token` from a user balance to an arbitrary address.\n     * @param token The token address.\n     * @param amount The amount to be withdrawn.\n     * @param to The payee address.\n     */\n    function withdrawFunds(\n        address token,\n        uint256 amount,\n        address to\n    ) external;\n\n    /**\n     * @dev Returns the amount of `token`, currently accumulated by the protocol.\n     * @param token The token address.\n     * @return Balance of `token`.\n     */\n    function protocolBalance(address token) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of protocol balances in various tokens.\n     * @return List of balances.\n     */\n    function protocolBalances() external view returns (Accounts.Balance[] memory);\n\n    /**\n     * @dev Returns the amount of `token`, currently accumulated by the universe.\n     * @param universeId The universe ID.\n     * @param token The token address.\n     * @return Balance of `token`.\n     */\n    function universeBalance(uint256 universeId, address token) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of universe balances in various tokens.\n     * @param universeId The universe ID.\n     * @return List of balances.\n     */\n    function universeBalances(uint256 universeId) external view returns (Accounts.Balance[] memory);\n\n    /**\n     * @dev Returns the amount of `token`, currently accumulated by the user.\n     * @param account The account to query the balance for.\n     * @param token The token address.\n     * @return Balance of `token`.\n     */\n    function balance(address account, address token) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of user balances in various tokens.\n     * @param account The account to query the balance for.\n     * @return List of balances.\n     */\n    function balances(address account) external view returns (Accounts.Balance[] memory);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/listing/IListingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../asset/Assets.sol\";\nimport \"../asset/IAssetController.sol\";\nimport \"../listing/IListingController.sol\";\nimport \"./Listings.sol\";\n\ninterface IListingManager {\n    /**\n     * @dev Thrown when the message sender doesn't match the asset lister address.\n     */\n    error CallerIsNotAssetLister();\n\n    /**\n     * @dev Thrown when the original asset cannot be withdrawn because of active rentals\n     * or other activity that requires asset to stay in the vault.\n     */\n    error AssetIsLocked();\n\n    /**\n     * @dev Emitted when a new asset is listed for renting.\n     * @param listingId Listing ID.\n     * @param listingGroupId Listing group ID.\n     * @param lister Lister account address.\n     * @param asset Listing asset.\n     * @param params Listing strategy parameters.\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\n     */\n    event AssetListed(\n        uint256 indexed listingId,\n        uint256 indexed listingGroupId,\n        address indexed lister,\n        Assets.Asset asset,\n        Listings.Params params,\n        uint32 maxLockPeriod\n    );\n\n    /**\n     * @dev Emitted when the asset is no longer available for renting.\n     * @param listingId Listing ID.\n     * @param lister Lister account address.\n     * @param unlocksAt The earliest possible time when the asset can be returned to the owner.\n     */\n    event AssetDelisted(uint256 indexed listingId, address indexed lister, uint32 unlocksAt);\n\n    /**\n     * @dev Emitted when the asset is returned to the `lister`.\n     * @param listingId Listing ID.\n     * @param lister Lister account address.\n     * @param asset Returned asset.\n     */\n    event AssetWithdrawn(uint256 indexed listingId, address indexed lister, Assets.Asset asset);\n\n    /**\n     * @dev Emitted when the listing is paused.\n     * @param listingId Listing ID.\n     */\n    event ListingPaused(uint256 indexed listingId);\n\n    /**\n     * @dev Emitted when the listing pause is lifted.\n     * @param listingId Listing ID.\n     */\n    event ListingUnpaused(uint256 indexed listingId);\n\n    /**\n     * @dev Performs new asset listing.\n     * Emits an {AssetListed} event.\n     * @param asset Asset to be listed.\n     * @param params Listing strategy parameters.\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\n     * @return listingId New listing ID.\n     * @return listingGroupId Listing group ID.\n     */\n    function listAsset(\n        Assets.Asset calldata asset,\n        Listings.Params calldata params,\n        uint32 maxLockPeriod,\n        bool immediatePayout\n    ) external returns (uint256 listingId, uint256 listingGroupId);\n\n    /**\n     * @dev Marks the asset as being delisted. This operation in irreversible.\n     * After delisting, the asset can only be withdrawn when it has no active rentals.\n     * Emits an {AssetDelisted} event.\n     * @param listingId Listing ID.\n     */\n    function delistAsset(uint256 listingId) external;\n\n    /**\n     * @dev Returns the asset back to the lister.\n     * Emits an {AssetWithdrawn} event.\n     * @param listingId Listing ID.\n     */\n    function withdrawAsset(uint256 listingId) external;\n\n    /**\n     * @dev Puts the listing on pause.\n     * Emits a {ListingPaused} event.\n     * @param listingId Listing ID.\n     */\n    function pauseListing(uint256 listingId) external;\n\n    /**\n     * @dev Lifts the listing pause.\n     * Emits a {ListingUnpaused} event.\n     * @param listingId Listing ID.\n     */\n    function unpauseListing(uint256 listingId) external;\n\n    /**\n     * @dev Returns the listing details by the listing ID.\n     * @param listingId Listing ID.\n     * @return Listing details.\n     */\n    function listingInfo(uint256 listingId) external view returns (Listings.Listing memory);\n\n    /**\n     * @dev Returns the number of currently registered listings.\n     * @return Listing count.\n     */\n    function listingCount() external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered listings.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Listing IDs.\n     * @return Listings.\n     */\n    function listings(uint256 offset, uint256 limit)\n        external\n        view\n        returns (uint256[] memory, Listings.Listing[] memory);\n\n    /**\n     * @dev Returns the number of currently registered listings for the particular lister account.\n     * @param lister Lister address.\n     * @return Listing count.\n     */\n    function userListingCount(address lister) external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\n     * @param lister Lister address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Listing IDs.\n     * @return Listings.\n     */\n    function userListings(\n        address lister,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\n\n    /**\n     * @dev Returns the number of currently registered listings for the particular original asset address.\n     * @param original Original asset address.\n     * @return Listing count.\n     */\n    function assetListingCount(address original) external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the particular original asset address.\n     * @param original Original asset address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Listing IDs.\n     * @return Listings.\n     */\n    function assetListings(\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\n\n    /**\n     * @dev Returns listing strategy controller.\n     * @param strategyId Listing strategy ID.\n     * @return Listing controller address.\n     */\n    function listingController(bytes4 strategyId) external view returns (address);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/renting/IRentingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Rentings.sol\";\n\ninterface IRentingManager {\n    /**\n     * @dev Thrown when the message sender doesn't match the renter address.\n     */\n    error CallerIsNotRenter();\n\n    /**\n     * @dev Emitted when the warped asset is rented.\n     * @param rentalId Rental agreement ID.\n     * @param renter The renter account address.\n     * @param listingId The corresponding ID of the original asset listing.\n     * @param warpedAsset Rented warped asset.\n     * @param startTime The rental agreement staring time.\n     * @param endTime The rental agreement ending time.\n     */\n    event AssetRented(\n        uint256 indexed rentalId,\n        address indexed renter,\n        uint256 indexed listingId,\n        Assets.Asset warpedAsset,\n        uint32 startTime,\n        uint32 endTime\n    );\n\n    /**\n     * @dev Returns token amount from specific collection rented by particular account.\n     * @param warpedCollectionId Warped collection ID.\n     * @param renter The renter account address.\n     * @return Rented value.\n     */\n    function collectionRentedValue(bytes32 warpedCollectionId, address renter) external view returns (uint256);\n\n    /**\n     * @dev Returns the rental status of a given warped asset.\n     * @param warpedAssetId Warped asset ID.\n     * @return The asset rental status.\n     */\n    function assetRentalStatus(Assets.AssetId calldata warpedAssetId) external view returns (Rentings.RentalStatus);\n\n    /**\n     * @dev Evaluates renting params and returns rental fee breakdown.\n     * @param rentingParams Renting parameters.\n     * @return Rental fee breakdown.\n     */\n    function estimateRent(Rentings.Params calldata rentingParams) external view returns (Rentings.RentalFees memory);\n\n    /**\n     * @dev Performs renting operation.\n     * @param rentingParams Renting parameters.\n     * @param maxPaymentAmount Maximal payment amount the renter is willing to pay.\n     * @return New rental ID.\n     */\n    function rent(Rentings.Params calldata rentingParams, uint256 maxPaymentAmount) external returns (uint256);\n\n    /**\n     * @dev Returns the rental agreement details.\n     * @param rentalId Rental agreement ID.\n     * @return Rental agreement details.\n     */\n    function rentalAgreementInfo(uint256 rentalId) external view returns (Rentings.Agreement memory);\n\n    /**\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\n     * @param renter Renter address.\n     * @return Rental agreement count.\n     */\n    function userRentalCount(address renter) external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\n     * @param renter Renter address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Rental agreement IDs.\n     * @return Rental agreements.\n     */\n    function userRentalAgreements(\n        address renter,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/asset/IAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../warper/IWarperManager.sol\";\nimport \"../warper/IWarperController.sol\";\n\ninterface IAssetManager {\n    /**\n     * @dev Register a new asset.\n     * @param assetClass Asset class identifier.\n     * @param original The original assets address.\n     */\n    function registerAsset(bytes4 assetClass, address original) external;\n\n    /**\n     * @dev Retrieve the asset class controller for a given assetClass.\n     * @param assetClass Asset class identifier.\n     * @return The asset class controller.\n     */\n    function assetClassController(bytes4 assetClass) external view returns (address);\n\n    /**\n     * @dev Check if the given account is the admin of a warper.\n     * @param warper Address of the warper.\n     * @param account The users account to checked for the admin permissions on the warper.\n     * @return True if the account is the admin of the warper.\n     */\n    function isWarperAdmin(address warper, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the number of currently supported assets.\n     * @return Asset count.\n     */\n    function supportedAssetCount() external view returns (uint256);\n\n    /**\n     * @dev Returns the list of all supported asset addresses.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return List of original asset addresses.\n     * @return List of asset config structures.\n     */\n    function supportedAssets(uint256 offset, uint256 limit)\n        external\n        view\n        returns (address[] memory, Assets.AssetConfig[] memory);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/metahub/IProtocolConfigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Protocol.sol\";\nimport \"../warper/IWarperManager.sol\";\n\ninterface IProtocolConfigManager {\n    /**\n     * @dev Raised when the caller is not the WarperManager contract.\n     */\n    error CallerIsNotWarperManager();\n\n    /**\n     * @dev Emitted when a protocol rental fee is changed.\n     * @param rentalFeePercent New protocol rental fee percentage.\n     */\n    event ProtocolRentalFeeChanged(uint16 rentalFeePercent);\n\n    /**\n     * @dev Updates the protocol rental fee percentage.\n     * @param rentalFeePercent New protocol rental fee percentage.\n     */\n    function setProtocolRentalFeePercent(uint16 rentalFeePercent) external;\n\n    /**\n     * @dev Returns the protocol rental fee percentage.\n     * @return protocol fee percent.\n     */\n    function protocolRentalFeePercent() external view returns (uint16);\n\n    /**\n     * @dev Returns the base token that's used for stable price denomination.\n     * @return The base token address.\n     */\n    function baseToken() external view returns (address);\n\n    /**\n     * @dev Get thee Warper Controller contracts address for a given warper.\n     * @param warper the warper address.\n     * @return The Warper Controller address.\n     */\n    function warperController(address warper) external view returns (address);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/accounting/Accounts.sol": {
      "content": "// solhint-disable private-vars-leading-underscore\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\";\nimport \"../renting/Rentings.sol\";\nimport \"../universe/IUniverseRegistry.sol\";\nimport \"../listing/Listings.sol\";\nimport \"./IPaymentManager.sol\";\n\nlibrary Accounts {\n    using Accounts for Account;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.AddressToUintMap;\n\n    /**\n     * @dev Thrown when the estimated rental fee calculated upon renting\n     * is higher than maximal payment amount the renter is willing to pay.\n     */\n    error RentalFeeSlippage();\n\n    /**\n     * @dev Thrown when the amount requested to be paid out is not valid.\n     */\n    error InvalidWithdrawalAmount(uint256 amount);\n\n    /**\n     * @dev Thrown when the amount requested to be paid out is larger than available balance.\n     */\n    error InsufficientBalance(uint256 balance);\n\n    /**\n     * @dev A structure that describes account balance in ERC20 tokens.\n     */\n    struct Balance {\n        address token;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Describes an account state.\n     * @param tokenBalances Mapping from an ERC20 token address to the amount.\n     */\n    struct Account {\n        EnumerableMapUpgradeable.AddressToUintMap tokenBalances;\n    }\n\n    /**\n     * @dev Transfers funds from the account balance to the specific address after validating balance sufficiency.\n     */\n    function withdraw(\n        Account storage self,\n        address token,\n        uint256 amount,\n        address to\n    ) external {\n        if (amount == 0) revert InvalidWithdrawalAmount(amount);\n        uint256 currentBalance = self.balance(token);\n        if (amount > currentBalance) revert InsufficientBalance(currentBalance);\n        unchecked {\n            self.tokenBalances.set(token, currentBalance - amount);\n        }\n        IERC20Upgradeable(token).safeTransfer(to, amount);\n    }\n\n    struct UserEarning {\n        IPaymentManager.EarningType earningType;\n        address account;\n        uint256 value;\n        address token;\n    }\n\n    struct RentalEarnings {\n        UserEarning[] userEarnings;\n        // Universe\n        uint256 universeId;\n        uint256 universeEarningValue;\n        address universeEarningToken;\n        // Protocol\n        uint256 protocolEarningValue;\n        address protocolEarningToken;\n    }\n\n    function handleRentalPayment(\n        Accounts.Registry storage self,\n        Rentings.Params calldata rentingParams,\n        Rentings.RentalFees calldata fees,\n        address payer,\n        uint256 maxPaymentAmount,\n        IWarperManager warperManager,\n        Listings.Registry storage listingRegistry\n    ) external returns (RentalEarnings memory earnings) {\n        // Ensure no rental fee payment slippage.\n        if (fees.total > maxPaymentAmount) revert RentalFeeSlippage();\n\n        // The amount of payment tokens to be accumulated on the Metahub for future payouts.\n        // This will include all fees which are not being paid out immediately.\n        uint256 accumulatedTokens = 0;\n\n        // Initialize user earnings array. Currently we only support earnings for single user, who is the lister.\n        earnings.userEarnings = new UserEarning[](1);\n\n        // Handle lister fee component.\n        Listings.Listing storage listing = listingRegistry.listings[rentingParams.listingId];\n        UserEarning memory listerEarning = UserEarning({\n            earningType: IPaymentManager.EarningType.LISTER_FEE,\n            account: listing.lister,\n            value: fees.listerBaseFee + fees.listerPremium,\n            token: rentingParams.paymentToken\n        });\n        earnings.userEarnings[0] = listerEarning;\n\n        // If the lister has not requested immediate payout, the earned amount is added to the lister balance.\n        // The direct payout case is handled along with other transfers later.\n        if (!listing.immediatePayout) {\n            self.users[listerEarning.account].increaseBalance(listerEarning.token, listerEarning.value);\n            accumulatedTokens += listerEarning.value;\n        }\n\n        // Handle universe fee component.\n        earnings.universeId = warperManager.warperInfo(rentingParams.warper).universeId;\n        earnings.universeEarningValue = fees.universeBaseFee + fees.universePremium;\n        earnings.universeEarningToken = rentingParams.paymentToken;\n        // Increase universe balance.\n        self.universes[earnings.universeId].increaseBalance(\n            earnings.universeEarningToken,\n            earnings.universeEarningValue\n        );\n        accumulatedTokens += earnings.universeEarningValue;\n\n        // Handle protocol fee component.\n        earnings.protocolEarningValue = fees.protocolFee;\n        earnings.protocolEarningToken = rentingParams.paymentToken;\n        self.protocol.increaseBalance(earnings.protocolEarningToken, earnings.protocolEarningValue);\n        accumulatedTokens += earnings.protocolEarningValue;\n\n        // Proceed with transfers.\n        // If immediate payout requested, transfer the lister earnings directly to the lister account.\n        if (listing.immediatePayout && listerEarning.value > 0) {\n            IERC20Upgradeable(listerEarning.token).safeTransferFrom(payer, listerEarning.account, listerEarning.value);\n        }\n\n        // Transfer the accumulated token amount from payer to the metahub.\n        if (accumulatedTokens > 0) {\n            IERC20Upgradeable(rentingParams.paymentToken).safeTransferFrom(payer, address(this), accumulatedTokens);\n        }\n    }\n\n    /**\n     * @dev Increments value of the particular account balance.\n     */\n    function increaseBalance(\n        Account storage self,\n        address token,\n        uint256 amount\n    ) internal {\n        uint256 currentBalance = self.balance(token);\n        self.tokenBalances.set(token, currentBalance + amount);\n    }\n\n    /**\n     * @dev Returns account current balance.\n     * Does not revert if `token` is not in the map.\n     */\n    function balance(Account storage self, address token) internal view returns (uint256) {\n        (, uint256 value) = self.tokenBalances.tryGet(token);\n        return value;\n    }\n\n    /**\n     * @dev Returns the list of account balances in various tokens.\n     */\n    function balances(Account storage self) internal view returns (Balance[] memory) {\n        uint256 length = self.tokenBalances.length();\n        Balance[] memory allBalances = new Balance[](length);\n        for (uint256 i = 0; i < length; i++) {\n            (address token, uint256 amount) = self.tokenBalances.at(i);\n            allBalances[i] = Balance({token: token, amount: amount});\n        }\n        return allBalances;\n    }\n\n    /**\n     * @dev Account registry.\n     * @param protocol The protocol account state.\n     * @param universes Mapping from a universe ID to the universe account state.\n     * @param users Mapping from a user address to the account state.\n     */\n    struct Registry {\n        Account protocol;\n        mapping(uint256 => Account) universes;\n        mapping(address => Account) users;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableMap.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSetUpgradeable.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\n */\nlibrary EnumerableMapUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSetUpgradeable.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/universe/IUniverseRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IUniverseRegistry {\n    /**\n     * @dev Thrown when a check is made where the given account must also be the universe owner.\n     */\n    error AccountIsNotUniverseOwner(address account);\n\n    /**\n     * @dev Thrown when a the supplied universe name is empty.\n     */\n    error EmptyUniverseName();\n\n    /**\n     * @dev Thrown when trying to read universe data for a universe is not registered.\n     */\n    error QueryForNonexistentUniverse(uint256 universeId);\n\n    /**\n     * @dev Emitted when a universe is created.\n     * @param universeId Universe ID.\n     * @param name Universe name.\n     */\n    event UniverseCreated(uint256 indexed universeId, string name);\n\n    /**\n     * @dev Emitted when a universe name is changed.\n     * @param universeId Universe ID.\n     * @param name The newly set name.\n     */\n    event UniverseNameChanged(uint256 indexed universeId, string name);\n\n    /**\n     * @dev Emitted when universe rental fee is changed.\n     * @param universeId Universe ID.\n     * @param rentalFeePercent The newly rental fee.\n     */\n    event UniverseRentalFeeChanged(uint256 indexed universeId, uint16 rentalFeePercent);\n\n    /**\n     * @dev Updates the universe token base URI.\n     * @param baseURI New base URI. Must include a trailing slash (\"/\").\n     */\n    function setUniverseTokenBaseURI(string calldata baseURI) external;\n\n    /**\n     * @dev The universe properties & initial configuration params.\n     * @param name The universe name.\n     * @param rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\n     */\n    struct UniverseParams {\n        string name;\n        uint16 rentalFeePercent;\n    }\n\n    /**\n     * @dev Creates new Universe. This includes minting new universe NFT,\n     * where the caller of this method becomes the universe owner.\n     * @param params The universe properties & initial configuration params.\n     * @return Universe ID (universe token ID).\n     */\n    function createUniverse(UniverseParams calldata params) external returns (uint256);\n\n    /**\n     * @dev Update the universe name.\n     * @param universeId The unique identifier for the universe.\n     * @param universeName The universe name to set.\n     */\n    function setUniverseName(uint256 universeId, string memory universeName) external;\n\n    /**\n     * @dev Update the universe rental fee percent.\n     * @param universeId The unique identifier for the universe.\n     * @param rentalFeePercent The universe rental fee percent.\n     */\n    function setUniverseRentalFeePercent(uint256 universeId, uint16 rentalFeePercent) external;\n\n    /**\n     * @dev Returns Universe owner address.\n     * @param universeId Universe ID.\n     * @return Universe owner.\n     */\n    function universeOwner(uint256 universeId) external view returns (address);\n\n    /**\n     * @dev Returns Universe rental fee percent.\n     * @param universeId Universe ID.\n     * @return universe fee percent.\n     */\n    function universeRentalFeePercent(uint256 universeId) external view returns (uint16);\n\n    /**\n     * @dev Returns name.\n     * @param universeId Universe ID.\n     * @return universe name.\n     */\n    function universeName(uint256 universeId) external view returns (string memory);\n\n    /**\n     * @dev Returns the Universe token address.\n     */\n    function universeToken() external view returns (address);\n\n    /**\n     * @dev Returns the Universe token base URI.\n     */\n    function universeTokenBaseURI() external view returns (string memory);\n\n    /**\n     * @dev Aggregate and return Universe data.\n     * @param universeId Universe-specific ID.\n     * @return name The name of the universe.\n     * @return rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\n     */\n    function universe(uint256 universeId) external view returns (string memory name, uint16 rentalFeePercent);\n\n    /**\n     * @dev Reverts if the universe owner is not the provided account address.\n     * @param universeId Universe ID.\n     * @param account The address of the expected owner.\n     */\n    function checkUniverseOwner(uint256 universeId, address account) external view;\n\n    /**\n     * @dev Returns `true` if the universe owner is the supplied account address.\n     * @param universeId Universe ID.\n     * @param account The address of the expected owner.\n     */\n    function isUniverseOwner(uint256 universeId, address account) external view returns (bool);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/listing/Listings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../asset/Assets.sol\";\nimport \"./IListingController.sol\";\nimport \"./IListingStrategyRegistry.sol\";\n\nlibrary Listings {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using Listings for Registry;\n    using Listings for Listing;\n    using Assets for Assets.Asset;\n\n    /**\n     * @dev Thrown when the `listingId` is invalid or the asset has been delisted.\n     */\n    error NotListed(uint256 listingId);\n\n    /**\n     * @dev Thrown when the `listingId` has never been registered.\n     */\n    error ListingIsNotRegistered(uint256 listingId);\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the listing being paused.\n     */\n    error ListingIsPaused();\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the listing not being paused.\n     */\n    error ListingIsNotPaused();\n\n    /**\n     * @dev Thrown when attempting to lock the listed asset for the period longer than the lister allowed.\n     */\n    error InvalidLockPeriod(uint32 period);\n\n    /**\n     * @dev Thrown when the listing strategy is not registered or deprecated.\n     * @param strategyId Unsupported listing strategy ID.\n     */\n    error UnsupportedListingStrategy(bytes4 strategyId);\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the listing group being nonempty.\n     * @param listingGroupId Listing group ID.\n     */\n    error ListingGroupIsNotEmpty(uint256 listingGroupId);\n\n    /**\n     * @dev Thrown when the provided `account` doesn't match the listing group owner address.\n     * @param listingGroupId Listing group ID.\n     * @param account Invalid owner account.\n     */\n    error InvalidListingGroupOwner(uint256 listingGroupId, address account);\n\n    /*\n     * @dev Listing strategy identifiers to be used across the system:\n     */\n    bytes4 public constant FIXED_PRICE = bytes4(keccak256(\"FIXED_PRICE\"));\n    bytes4 public constant FIXED_PRICE_WITH_REWARD = bytes4(keccak256(\"FIXED_PRICE_WITH_REWARD\"));\n\n    /**\n     * @dev Listing params.\n     * The layout of `data` might vary for different listing strategies.\n     * For example, in case of FIXED_PRICE strategy, the `data` might contain only base rate,\n     * and for more advanced auction strategies it might include period, min bid step etc.\n     * @param strategy Listing strategy ID\n     * @param data Listing strategy data.\n     */\n    struct Params {\n        bytes4 strategy;\n        bytes data;\n    }\n\n    /**\n     * @dev Listing structure.\n     * @param asset Listed asset structure.\n     * @param params Listing strategy parameters.\n     * @param lister Lister account address.\n     * @param maxLockPeriod The maximum amount of time the asset owner can wait before getting the asset back.\n     * @param lockedTill The earliest possible time when the asset can be returned to the owner.\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\n     * @param delisted Indicates whether the asset is delisted.\n     * @param paused Indicates whether the listing is paused.\n     * @param groupId Listing group ID.\n     */\n    struct Listing {\n        // slots 0-2\n        Assets.Asset asset;\n        // slot 3-4\n        Params params;\n        // slot 5 (1 byte)\n        address lister;\n        uint32 maxLockPeriod;\n        uint32 lockedTill;\n        bool immediatePayout;\n        bool delisted;\n        bool paused;\n        // slot 6\n        uint256 groupId;\n    }\n\n    /**\n     * @dev Listing related data associated with the specific account.\n     * @param listingIndex The set of listing IDs.\n     * @param listingGroupIndex The set of listing group IDs.\n     */\n    struct ListerInfo {\n        EnumerableSetUpgradeable.UintSet listingIndex;\n        EnumerableSetUpgradeable.UintSet listingGroupIndex;\n    }\n\n    /**\n     * @dev Listing related data associated with the specific account.\n     * @param listingIndex The set of listing IDs.\n     */\n    struct AssetInfo {\n        EnumerableSetUpgradeable.UintSet listingIndex;\n    }\n\n    /**\n     * @dev Listing group information.\n     * @param name The listing group name.\n     * @param owner The listing group owner address.\n     * @param listingIndex The set of listing IDs which belong to the group.\n     */\n    struct ListingGroupInfo {\n        string name;\n        address owner;\n        EnumerableSetUpgradeable.UintSet listingIndex;\n    }\n\n    /**\n     * @dev Listing registry.\n     * @param idTracker Listing ID tracker (incremental counter).\n     * @param strategyRegistry Listing strategy registry contract.\n     * @param listingIndex The global set of registered listing IDs.\n     * @param listings Mapping from listing ID to the listing info.\n     * @param listers Mapping from lister address to the lister info.\n     * @param assets Mapping from an asset address to the asset info.\n     * @param listingGroups Mapping from listing group ID to the listing group info.\n     */\n    struct Registry {\n        CountersUpgradeable.Counter listingIdTracker;\n        IListingStrategyRegistry strategyRegistry;\n        EnumerableSetUpgradeable.UintSet listingIndex;\n        mapping(uint256 => Listing) listings;\n        mapping(address => ListerInfo) listers;\n        mapping(address => AssetInfo) assets;\n        CountersUpgradeable.Counter listingGroupIdTracker;\n        mapping(uint256 => ListingGroupInfo) listingGroups;\n    }\n\n    /**\n     * @dev Puts the listing on pause.\n     */\n    function pause(Listing storage self) internal {\n        if (self.paused) revert ListingIsPaused();\n\n        self.paused = true;\n    }\n\n    /**\n     * @dev Lifts the listing pause.\n     */\n    function unpause(Listing storage self) internal {\n        if (!self.paused) revert ListingIsNotPaused();\n\n        self.paused = false;\n    }\n\n    /**\n     * Determines whether the listing is active.\n     */\n    function listed(Listing storage self) internal view returns (bool) {\n        return self.lister != address(0) && !self.delisted;\n    }\n\n    /**\n     * @dev Reverts if the listing is paused.\n     */\n    function checkNotPaused(Listing storage self) internal view {\n        if (self.paused) revert ListingIsPaused();\n    }\n\n    /*\n     * @dev Validates lock period.\n     */\n    function isValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view returns (bool) {\n        return (lockPeriod > 0 && lockPeriod <= self.maxLockPeriod);\n    }\n\n    /**\n     * @dev Reverts if the lock period is not valid.\n     */\n    function checkValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view {\n        if (!self.isValidLockPeriod(lockPeriod)) revert InvalidLockPeriod(lockPeriod);\n    }\n\n    /**\n     * @dev Extends listing lock time.\n     * Does not modify the state if current lock time is larger.\n     */\n    function addLock(Listing storage self, uint32 unlockTimestamp) internal {\n        // Listing is already locked till later time, no need to extend locking period.\n        if (self.lockedTill >= unlockTimestamp) return;\n        // Extend listing lock.\n        self.lockedTill = unlockTimestamp;\n    }\n\n    /**\n     * @dev Registers new listing group.\n     * @param name The listing group name.\n     * @param owner The listing group owner address.\n     * @return listingGroupId New listing group ID.\n     */\n    function registerListingGroup(\n        Registry storage self,\n        string memory name,\n        address owner\n    ) external returns (uint256 listingGroupId) {\n        listingGroupId = _registerListingGroup(self, name, owner);\n    }\n\n    /**\n     * @dev Removes listing group data.\n     * @param listingGroupId The ID of the listing group to be deleted.\n     */\n    function removeListingGroup(Registry storage self, uint256 listingGroupId) external {\n        ListingGroupInfo storage listingGroup = self.listingGroups[listingGroupId];\n\n        // Deleting nonempty listing groups is forbidden.\n        if (listingGroup.listingIndex.length() > 0) revert ListingGroupIsNotEmpty(listingGroupId);\n\n        // Remove the listing group ID from the user account data.\n        self.listers[listingGroup.owner].listingGroupIndex.remove(listingGroupId);\n\n        // Delete listing group.\n        delete self.listingGroups[listingGroupId];\n    }\n\n    /**\n     * @dev Registers new listing.\n     * @return listingId New listing ID.\n     * @return listingGroupId Effective listing group ID.\n     */\n    function register(Registry storage self, Listing memory listing)\n        external\n        returns (uint256 listingId, uint256 listingGroupId)\n    {\n        // Generate new listing ID.\n        self.listingIdTracker.increment();\n        listingId = self.listingIdTracker.current();\n\n        // Listing is being added to an existing group.\n        if (listing.groupId != 0) {\n            listingGroupId = listing.groupId;\n            self.checkListingGroupOwner(listingGroupId, listing.lister);\n        } else {\n            // Otherwise the new listing group is created and the listing is added to this group by default.\n            listingGroupId = _registerListingGroup(self, \"\", listing.lister);\n            listing.groupId = listingGroupId;\n        }\n\n        // Add new listing ID to the global index.\n        self.listingIndex.add(listingId);\n        // Add new listing ID to the listing group index.\n        self.listingGroups[listingGroupId].listingIndex.add(listingId);\n        // Add user listing data.\n        self.listers[listing.lister].listingIndex.add(listingId);\n        // Add asset listing data.\n        self.assets[listing.asset.token()].listingIndex.add(listingId);\n        // Store new listing record.\n        self.listings[listingId] = listing;\n    }\n\n    /**\n     * @dev Removes listing data.\n     * @param listingId The ID of the listing to be deleted.\n     */\n    function remove(Registry storage self, uint256 listingId) external {\n        address lister = self.listings[listingId].lister;\n        address original = self.listings[listingId].asset.token();\n        uint256 listingGroupId = self.listings[listingId].groupId;\n\n        // Remove the listing ID from the global index.\n        self.listingIndex.remove(listingId);\n        // Remove the listing ID from the group index.\n        self.listingGroups[listingGroupId].listingIndex.remove(listingId);\n        // Remove user listing data.\n        self.listers[lister].listingIndex.remove(listingId);\n        // Remove asset listing data.\n        self.assets[original].listingIndex.remove(listingId);\n        // Delete listing.\n        delete self.listings[listingId];\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings.\n     */\n    function allListings(\n        Registry storage self,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listing[] memory) {\n        return self.paginateIndexedListings(self.listingIndex, offset, limit);\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\n     */\n    function userListings(\n        Registry storage self,\n        address lister,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listing[] memory) {\n        return self.paginateIndexedListings(self.listers[lister].listingIndex, offset, limit);\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the original asset.\n     */\n    function assetListings(\n        Registry storage self,\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listing[] memory) {\n        return self.paginateIndexedListings(self.assets[original].listingIndex, offset, limit);\n    }\n\n    /**\n     * @dev Reverts if listing has not been registered.\n     * @param listingId Listing ID.\n     */\n    function checkRegisteredListing(Registry storage self, uint256 listingId) external view {\n        if (!self.isRegisteredListing(listingId)) revert ListingIsNotRegistered(listingId);\n    }\n\n    /**\n     * @dev Reverts if the provided `account` doesn't match the listing group owner address.\n     * @param listingGroupId Listing group ID.\n     * @param account The account to check ownership for.\n     */\n    function checkListingGroupOwner(\n        Registry storage self,\n        uint256 listingGroupId,\n        address account\n    ) internal view {\n        if (self.listingGroups[listingGroupId].owner != account)\n            revert InvalidListingGroupOwner(listingGroupId, account);\n    }\n\n    /**\n     * @dev Checks listing registration by ID.\n     * @param listingId Listing ID.\n     */\n    function isRegisteredListing(Registry storage self, uint256 listingId) internal view returns (bool) {\n        return self.listings[listingId].lister != address(0);\n    }\n\n    /**\n     * @dev Reverts if listing strategy is not supported.\n     * @param strategyId Listing strategy ID.\n     */\n    function checkSupportedListingStrategy(Registry storage self, bytes4 strategyId) internal view {\n        if (!self.strategyRegistry.isRegisteredListingStrategy(strategyId))\n            revert UnsupportedListingStrategy(strategyId);\n    }\n\n    /**\n     * @dev Returns listing controller for strategy.\n     * @param strategyId Listing strategy ID.\n     */\n    function listingController(Registry storage self, bytes4 strategyId) internal view returns (IListingController) {\n        return IListingController(self.strategyRegistry.listingController(strategyId));\n    }\n\n    /**\n     * @dev Reverts if listing is not registered or has been already delisted.\n     * @param listingId Listing ID.\n     */\n    function checkListed(Registry storage self, uint256 listingId) internal view {\n        if (!self.listings[listingId].listed()) revert NotListed(listingId);\n    }\n\n    /**\n     * @dev Returns the number of currently registered listings.\n     */\n    function listingCount(Registry storage self) internal view returns (uint256) {\n        return self.listingIndex.length();\n    }\n\n    /**\n     * @dev Returns the number of currently registered listings for a particular lister account.\n     */\n    function userListingCount(Registry storage self, address lister) internal view returns (uint256) {\n        return self.listers[lister].listingIndex.length();\n    }\n\n    /**\n     * @dev Returns the number of currently registered listings for a particular original asset.\n     */\n    function assetListingCount(Registry storage self, address original) internal view returns (uint256) {\n        return self.assets[original].listingIndex.length();\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listing using provided index reference.\n     */\n    function paginateIndexedListings(\n        Registry storage self,\n        EnumerableSetUpgradeable.UintSet storage listingIndex,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (uint256[] memory, Listing[] memory) {\n        uint256 indexSize = listingIndex.length();\n        if (offset >= indexSize) return (new uint256[](0), new Listing[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        Listing[] memory listings = new Listing[](limit);\n        uint256[] memory listingIds = new uint256[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            listingIds[i] = listingIndex.at(offset + i);\n            listings[i] = self.listings[listingIds[i]];\n        }\n\n        return (listingIds, listings);\n    }\n\n    /**\n     * @dev Registers new listing group.\n     * @param name The listing group name.\n     * @param owner The listing group owner address.\n     * @return listingGroupId New listing group ID.\n     */\n    function _registerListingGroup(\n        Registry storage self,\n        string memory name,\n        address owner\n    ) private returns (uint256 listingGroupId) {\n        // Generate new listing group ID.\n        self.listingGroupIdTracker.increment();\n        listingGroupId = self.listingGroupIdTracker.current();\n\n        // Store new listing group record.\n        self.listingGroups[listingGroupId].name = name;\n        self.listingGroups[listingGroupId].owner = owner;\n\n        // Associate the new listing group with the user account.\n        self.listers[owner].listingGroupIndex.add(listingGroupId);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/asset/Assets.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./IAssetController.sol\";\nimport \"./IAssetVault.sol\";\nimport \"./IAssetClassRegistry.sol\";\n\nlibrary Assets {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using Address for address;\n    using Assets for Registry;\n    using Assets for Asset;\n\n    /*\n     * @dev This is the list of asset class identifiers to be used across the system.\n     */\n    bytes4 public constant ERC721 = bytes4(keccak256(\"ERC721\"));\n    bytes4 public constant ERC1155 = bytes4(keccak256(\"ERC1155\"));\n\n    bytes32 public constant ASSET_ID_TYPEHASH = keccak256(\"AssetId(bytes4 class,bytes data)\");\n\n    bytes32 public constant ASSET_TYPEHASH =\n        keccak256(\"Asset(AssetId id,uint256 value)AssetId(bytes4 class,bytes data)\");\n\n    /**\n     * @dev Thrown upon attempting to register an asset twice.\n     * @param asset Duplicate asset address.\n     */\n    error AssetIsAlreadyRegistered(address asset);\n\n    /**\n     * @dev Communicates asset identification information.\n     * The structure designed to be token-standard agnostic,\n     * so the layout of `data` might vary for different token standards.\n     * For example, in case of ERC721 token, the `data` will contain contract address and tokenId.\n     * @param class Asset class ID\n     * @param data Asset identification data.\n     */\n    struct AssetId {\n        bytes4 class;\n        bytes data;\n    }\n\n    /**\n     * @dev Calculates Asset ID hash\n     */\n    function hash(AssetId memory assetId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ASSET_ID_TYPEHASH, assetId.class, keccak256(assetId.data)));\n    }\n\n    /**\n     * @dev Extracts token contract address from the Asset ID structure.\n     * The address is the common attribute for all assets regardless of their asset class.\n     */\n    function token(AssetId memory self) internal pure returns (address) {\n        return abi.decode(self.data, (address));\n    }\n\n    /**\n     * @dev Uniformed structure to describe arbitrary asset (token) and its value.\n     * @param id Asset ID structure.\n     * @param value Asset value (amount).\n     */\n    struct Asset {\n        AssetId id;\n        uint256 value;\n    }\n\n    /**\n     * @dev Calculates Asset hash\n     */\n    function hash(Asset memory asset) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ASSET_TYPEHASH, hash(asset.id), asset.value));\n    }\n\n    /**\n     * @dev Extracts token contract address from the Asset structure.\n     * The address is the common attribute for all assets regardless of their asset class.\n     */\n    function token(Asset memory self) internal pure returns (address) {\n        return abi.decode(self.id.data, (address));\n    }\n\n    /**\n     * @dev Original asset data.\n     * @param controller Asset controller.\n     * @param assetClass The asset class identifier.\n     * @param vault Asset vault.\n     */\n    struct AssetConfig {\n        IAssetController controller;\n        bytes4 assetClass;\n        IAssetVault vault;\n    }\n\n    /**\n     * @dev Asset registry.\n     * @param classRegistry Asset class registry contract.\n     * @param assetIndex Set of registered asset addresses.\n     * @param assets Mapping from asset address to the asset configuration.\n     */\n    struct Registry {\n        IAssetClassRegistry classRegistry;\n        EnumerableSetUpgradeable.AddressSet assetIndex;\n        mapping(address => AssetConfig) assets;\n    }\n\n    /**\n     * @dev Registers new asset.\n     */\n    function registerAsset(\n        Registry storage self,\n        bytes4 assetClass,\n        address asset\n    ) external {\n        if (!self.assetIndex.add(asset)) revert AssetIsAlreadyRegistered(asset);\n\n        IAssetClassRegistry.ClassConfig memory assetClassConfig = self.classRegistry.assetClassConfig(assetClass);\n        self.assets[asset] = AssetConfig({\n            controller: IAssetController(assetClassConfig.controller),\n            assetClass: assetClass,\n            vault: IAssetVault(assetClassConfig.vault)\n        });\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings and their corresponding asset configs.\n     */\n    function supportedAssets(\n        Registry storage self,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, AssetConfig[] memory) {\n        uint256 indexSize = self.assetIndex.length();\n        if (offset >= indexSize) return (new address[](0), new AssetConfig[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        AssetConfig[] memory assetConfigs = new AssetConfig[](limit);\n        address[] memory assetAddresses = new address[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            assetAddresses[i] = self.assetIndex.at(offset + i);\n            assetConfigs[i] = self.assets[assetAddresses[i]];\n        }\n        return (assetAddresses, assetConfigs);\n    }\n\n    /**\n     * @dev Transfers an asset to the vault using associated controller.\n     */\n    function transferAssetToVault(\n        Registry storage self,\n        Assets.Asset memory asset,\n        address from\n    ) external {\n        // Extract token address from asset struct and check whether the asset is supported.\n        address assetToken = asset.token();\n\n        // Transfer asset to the class asset specific vault.\n        address assetController = address(self.assets[assetToken].controller);\n        address assetVault = address(self.assets[assetToken].vault);\n        assetController.functionDelegateCall(\n            abi.encodeWithSelector(IAssetController.transferAssetToVault.selector, asset, from, assetVault)\n        );\n    }\n\n    /**\n     * @dev Transfers an asset from the vault using associated controller.\n     */\n    function returnAssetFromVault(Registry storage self, Assets.Asset memory asset) external {\n        address assetToken = asset.token();\n        address assetController = address(self.assets[assetToken].controller);\n        address assetVault = address(self.assets[assetToken].vault);\n\n        assetController.functionDelegateCall(\n            abi.encodeWithSelector(IAssetController.returnAssetFromVault.selector, asset, assetVault)\n        );\n    }\n\n    function assetCount(Registry storage self) internal view returns (uint256) {\n        return self.assetIndex.length();\n    }\n\n    /**\n     * @dev Checks asset registration by address.\n     */\n    function isRegisteredAsset(Registry storage self, address asset) internal view returns (bool) {\n        return self.assetIndex.contains(asset);\n    }\n\n    /**\n     * @dev Returns controller for asset class.\n     * @param assetClass Asset class ID.\n     */\n    function assetClassController(Registry storage self, bytes4 assetClass) internal view returns (address) {\n        return self.classRegistry.assetClassConfig(assetClass).controller;\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/metahub/Protocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nlibrary Protocol {\n    /**\n     * @dev Thrown when the provided token does not match with the configured base token.\n     */\n    error BaseTokenMismatch();\n\n    /**\n     * @dev Protocol configuration.\n     * @param baseToken ERC20 contract. Used as the price denominator.\n     * @param rentalFeePercent The fixed part of the total rental fee paid to protocol.\n     */\n    struct Config {\n        IERC20Upgradeable baseToken;\n        uint16 rentalFeePercent;\n    }\n\n    /**\n     * @dev Reverts if the `token` does not match the base one.\n     */\n    function checkBaseToken(Config storage self, address token) internal view {\n        if (token != address(self.baseToken)) revert BaseTokenMismatch();\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/Warpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"./IWarperController.sol\";\nimport \"./IWarperPresetFactory.sol\";\nimport \"../asset/Assets.sol\";\nimport \"./IWarperManager.sol\";\n\nlibrary Warpers {\n    using AddressUpgradeable for address;\n    using ERC165CheckerUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using Warpers for Registry;\n    using Assets for Assets.Asset;\n    using Assets for Assets.Registry;\n\n    /**\n     * @dev Thrown if provided warper address does not implement warper interface.\n     */\n    error InvalidWarperInterface();\n\n    /**\n     * @dev Thrown when the warper returned metahub address differs from the one it is being registered in.\n     * @param provided Metahub address returned by warper.\n     * @param required Required metahub address.\n     */\n    error WarperHasIncorrectMetahubReference(address provided, address required);\n\n    /**\n     * @dev Thrown when performing action or accessing data of an unknown warper.\n     * @param warper Warper address.\n     */\n    error WarperIsNotRegistered(address warper);\n\n    /**\n     * @dev Thrown upon attempting to register a warper twice.\n     * @param warper Duplicate warper address.\n     */\n    error WarperIsAlreadyRegistered(address warper);\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the warper being paused.\n     */\n    error WarperIsPaused();\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the warper not being paused.\n     */\n    error WarperIsNotPaused();\n\n    /**\n     * @dev Thrown when there are no registered warpers for a particular asset.\n     * @param asset Asset address.\n     */\n    error UnsupportedAsset(address asset);\n\n    /**\n     * @dev Thrown upon attempting to use the warper which is not registered for the provided asset.\n     */\n    error IncompatibleAsset(address asset);\n\n    /**\n     * @dev Registered warper data.\n     * @param assetClass The identifying asset class.\n     * @param original Original asset contract address.\n     * @param paused Indicates whether the warper is paused.\n     * @param controller Warper controller.\n     * @param name Warper name.\n     * @param universeId Warper universe ID.\n     */\n    struct Warper {\n        bytes4 assetClass;\n        address original;\n        bool paused;\n        IWarperController controller;\n        string name;\n        uint256 universeId;\n    }\n\n    /**\n     * @dev Reverts if the warper original does not match the `asset`;\n     */\n    function checkCompatibleAsset(Warper memory self, Assets.Asset memory asset) internal pure {\n        address original = asset.token();\n        if (self.original != original) revert IncompatibleAsset(original);\n    }\n\n    /**\n     * @dev Puts the warper on pause.\n     */\n    function pause(Warper storage self) internal {\n        if (self.paused) revert WarperIsPaused();\n\n        self.paused = true;\n    }\n\n    /**\n     * @dev Lifts the warper pause.\n     */\n    function unpause(Warper storage self) internal {\n        if (!self.paused) revert WarperIsNotPaused();\n\n        self.paused = false;\n    }\n\n    /**\n     * @dev Reverts if the warper is paused.\n     */\n    function checkNotPaused(Warper memory self) internal pure {\n        if (self.paused) revert WarperIsPaused();\n    }\n\n    /**\n     * @dev Warper registry.\n     * @param presetFactory Warper preset factory contract.\n     * @param warperIndex Set of registered warper addresses.\n     * @param universeWarperIndex Mapping from a universe ID to the set of warper addresses registered by the universe.\n     * @param assetWarperIndex Mapping from an original asset address to the set of warper addresses,\n     * registered for the asset.\n     * @param warpers Mapping from a warper address to the warper details.\n     */\n    struct Registry {\n        IWarperPresetFactory presetFactory;\n        EnumerableSetUpgradeable.AddressSet warperIndex;\n        mapping(uint256 => EnumerableSetUpgradeable.AddressSet) universeWarperIndex;\n        mapping(address => EnumerableSetUpgradeable.AddressSet) assetWarperIndex;\n        mapping(address => Warpers.Warper) warpers;\n    }\n\n    /**\n     * @dev Performs warper registration.\n     * @param warper Warper address.\n     * @param params Warper registration params.\n     */\n    function registerWarper(\n        Registry storage self,\n        address warper,\n        IWarperManager.WarperRegistrationParams calldata params,\n        IAssetClassRegistry assetClassRegistry\n    ) internal returns (bytes4 assetClass, address original) {\n        // Check that provided warper address is a valid contract.\n        if (!warper.isContract() || !warper.supportsInterface(type(IWarper).interfaceId)) {\n            revert InvalidWarperInterface();\n        }\n\n        // Check that warper has correct metahub reference.\n        address metahub = IWarper(warper).__metahub();\n        if (metahub != IWarperManager(address(this)).metahub())\n            revert WarperHasIncorrectMetahubReference(metahub, address(this));\n\n        // Check that warper asset class is supported.\n        assetClass = IWarper(warper).__assetClass();\n\n        // Retrieve warper controller based on assetClass.\n        // Controller resolution for unsupported asset class will revert.\n        IWarperController controller = IWarperController(assetClassRegistry.assetClassConfig(assetClass).controller);\n\n        // Ensure warper compatibility with the current generation of asset controller.\n        controller.checkCompatibleWarper(warper);\n\n        // Retrieve original asset address.\n        original = IWarper(warper).__original();\n\n        // Save warper record.\n        _register(\n            self,\n            warper,\n            Warpers.Warper({\n                original: original,\n                controller: controller,\n                name: params.name,\n                universeId: params.universeId,\n                paused: params.paused,\n                assetClass: assetClass\n            })\n        );\n    }\n\n    /**\n     * @dev Performs warper registration.\n     */\n    function _register(\n        Registry storage self,\n        address warperAddress,\n        Warper memory warper\n    ) private {\n        if (!self.warperIndex.add(warperAddress)) revert WarperIsAlreadyRegistered(warperAddress);\n\n        // Create warper main registration record.\n        self.warpers[warperAddress] = warper;\n        // Associate the warper with the universe.\n        self.universeWarperIndex[warper.universeId].add(warperAddress);\n        // Associate the warper with the original asset.\n        self.assetWarperIndex[warper.original].add(warperAddress);\n    }\n\n    /**\n     * @dev Removes warper data from the registry.\n     */\n    function remove(Registry storage self, address warperAddress) internal {\n        Warper storage warper = self.warpers[warperAddress];\n        // Clean up universe index.\n        self.universeWarperIndex[warper.universeId].remove(warperAddress);\n        // Clean up asset index.\n        self.assetWarperIndex[warper.original].remove(warperAddress);\n        // Clean up main index.\n        self.warperIndex.remove(warperAddress);\n        // Delete warper data.\n        delete self.warpers[warperAddress];\n    }\n\n    /**\n     * @dev Returns the paginated list of warpers belonging to the particular universe.\n     */\n    function universeWarpers(\n        Registry storage self,\n        uint256 universeId,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (address[] memory, Warpers.Warper[] memory) {\n        return self.paginateIndexedWarpers(self.universeWarperIndex[universeId], offset, limit);\n    }\n\n    /**\n     * @dev Returns the paginated list of warpers associated with the particular original asset.\n     */\n    function assetWarpers(\n        Registry storage self,\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (address[] memory, Warpers.Warper[] memory) {\n        return self.paginateIndexedWarpers(self.assetWarperIndex[original], offset, limit);\n    }\n\n    /**\n     * @dev Checks warper registration by address.\n     */\n    function isRegisteredWarper(Registry storage self, address warper) internal view returns (bool) {\n        return self.warperIndex.contains(warper);\n    }\n\n    /**\n     * @dev Reverts if warper is not registered.\n     */\n    function checkRegisteredWarper(Registry storage self, address warper) internal view {\n        if (!self.isRegisteredWarper(warper)) revert WarperIsNotRegistered(warper);\n    }\n\n    /**\n     * @dev Reverts if asset is not supported.\n     * @param asset Asset address.\n     */\n    function checkSupportedAsset(Registry storage self, address asset) internal view {\n        if (!self.isSupportedAsset(asset)) revert UnsupportedAsset(asset);\n    }\n\n    /**\n     * @dev Checks asset support by address.\n     * The supported asset should have at least one warper.\n     * @param asset Asset address.\n     */\n    function isSupportedAsset(Registry storage self, address asset) internal view returns (bool) {\n        return self.assetWarperIndex[asset].length() > 0;\n    }\n\n    /**\n     * @dev Returns the number of warpers belonging to the particular universe.\n     */\n    function universeWarperCount(Registry storage self, uint256 universeId) internal view returns (uint256) {\n        return self.universeWarperIndex[universeId].length();\n    }\n\n    /**\n     * @dev Returns the number of warpers associated with the particular original asset.\n     */\n    function assetWarperCount(Registry storage self, address original) internal view returns (uint256) {\n        return self.assetWarperIndex[original].length();\n    }\n\n    /**\n     * @dev Returns the paginated list of registered warpers using provided index reference.\n     */\n    function paginateIndexedWarpers(\n        Registry storage self,\n        EnumerableSetUpgradeable.AddressSet storage warperIndex,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (address[] memory, Warper[] memory) {\n        uint256 indexSize = warperIndex.length();\n        if (offset >= indexSize) return (new address[](0), new Warper[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        Warper[] memory warpers = new Warper[](limit);\n        address[] memory warperAddresses = new address[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            warperAddresses[i] = warperIndex.at(offset + i);\n            warpers[i] = self.warpers[warperAddresses[i]];\n        }\n\n        return (warperAddresses, warpers);\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/asset/IAssetController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"./Assets.sol\";\n\ninterface IAssetController is IERC165 {\n    /**\n     * @dev Thrown when the asset has invalid class for specific operation.\n     * @param provided Provided class ID.\n     * @param required Required class ID.\n     */\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Emitted when asset is transferred.\n     * @param asset Asset being transferred.\n     * @param from Asset sender.\n     * @param to Asset recipient.\n     * @param data Auxiliary data.\n     */\n    event AssetTransfer(Assets.Asset asset, address indexed from, address indexed to, bytes data);\n\n    /**\n     * @dev Returns controller asset class.\n     * @return Asset class ID.\n     */\n    function assetClass() external pure returns (bytes4);\n\n    /**\n     * @dev Transfers asset.\n     * Emits a {AssetTransfer} event.\n     * @param asset Asset being transferred.\n     * @param from Asset sender.\n     * @param to Asset recipient.\n     * @param data Auxiliary data.\n     */\n    function transfer(\n        Assets.Asset memory asset,\n        address from,\n        address to,\n        bytes memory data\n    ) external;\n\n    /**\n     * @dev Transfers asset from owner to the vault contract.\n     * @param asset Asset being transferred.\n     * @param assetOwner Original asset owner address.\n     * @param vault Asset vault contract address.\n     */\n    function transferAssetToVault(\n        Assets.Asset memory asset,\n        address assetOwner,\n        address vault\n    ) external;\n\n    /**\n     * @dev Transfers asset from the vault contract to the original owner.\n     * @param asset Asset being transferred.\n     * @param vault Asset vault contract address.\n     */\n    function returnAssetFromVault(Assets.Asset memory asset, address vault) external;\n\n    /**\n     * @dev Decodes asset ID structure and returns collection identifier.\n     * The collection ID is byte32 value which is calculated based on the asset class.\n     * For example, ERC721 collection can be identified by address only,\n     * but for ERC1155 it should be calculated based on address and token ID.\n     * @return Collection ID.\n     */\n    function collectionId(Assets.AssetId memory assetId) external pure returns (bytes32);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/asset/IAssetVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAssetVault is IERC165 {\n    /**\n     * @dev Thrown when the asset is not is found among vault inventory.\n     */\n    error AssetNotFound();\n\n    /**\n     * @dev Thrown when the function is called on the vault in recovery mode.\n     */\n    error VaultIsInRecoveryMode();\n\n    /**\n     * @dev Thrown when the asset return is not allowed, due to the vault state or the caller permissions.\n     */\n    error AssetReturnIsNotAllowed();\n\n    /**\n     * @dev Thrown when the asset deposit is not allowed, due to the vault state or the caller permissions.\n     */\n    error AssetDepositIsNotAllowed();\n\n    /**\n     * @dev Emitted when the vault is switched to recovery mode by `account`.\n     */\n    event RecoveryModeActivated(address account);\n\n    /**\n     * @dev Activates asset recovery mode.\n     * Emits a {RecoveryModeActivated} event.\n     */\n    function switchToRecoveryMode() external;\n\n    /**\n     * @notice Send ERC20 tokens to an address.\n     */\n    function withdrawERC20Tokens(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) external;\n\n    /**\n     * @dev Pauses the vault.\n     */\n    function pause() external;\n\n    /**\n     * @dev Unpauses the vault.\n     */\n    function unpause() external;\n\n    /**\n     * @dev Returns vault asset class.\n     * @return Asset class ID.\n     */\n    function assetClass() external pure returns (bytes4);\n\n    /**\n     * @dev Returns the Metahub address.\n     */\n    function metahub() external view returns (address);\n\n    /**\n     * @dev Returns vault recovery mode flag state.\n     * @return True when the vault is in recovery mode.\n     */\n    function isRecovery() external view returns (bool);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/asset/IAssetClassRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IAssetController.sol\";\nimport \"./IAssetVault.sol\";\n\ninterface IAssetClassRegistry {\n    /**\n     * @dev Thrown when the asset class supported by contract does not match the required one.\n     * @param provided Provided class ID.\n     * @param required Required class ID.\n     */\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Thrown upon attempting to register an asset class twice.\n     * @param assetClass Duplicate asset class ID.\n     */\n    error AssetClassIsAlreadyRegistered(bytes4 assetClass);\n\n    /**\n     * @dev Thrown upon attempting to work with unregistered asset class.\n     * @param assetClass Asset class ID.\n     */\n    error UnregisteredAssetClass(bytes4 assetClass);\n\n    /**\n     * @dev Thrown when the asset controller contract does not implement the required interface.\n     */\n    error InvalidAssetControllerInterface();\n\n    /**\n     * @dev Thrown when the vault contract does not implement the required interface.\n     */\n    error InvalidAssetVaultInterface();\n\n    /**\n     * @dev Emitted when the new asset class is registered.\n     * @param assetClass Asset class ID.\n     * @param controller Controller address.\n     * @param vault Vault address.\n     */\n    event AssetClassRegistered(bytes4 indexed assetClass, address indexed controller, address indexed vault);\n\n    /**\n     * @dev Emitted when the asset class controller is changed.\n     * @param assetClass Asset class ID.\n     * @param newController New controller address.\n     */\n    event AssetClassControllerChanged(bytes4 indexed assetClass, address indexed newController);\n\n    /**\n     * @dev Emitted when the asset class vault is changed.\n     * @param assetClass Asset class ID.\n     * @param newVault New vault address.\n     */\n    event AssetClassVaultChanged(bytes4 indexed assetClass, address indexed newVault);\n\n    /**\n     * @dev Asset class configuration.\n     * @param vault Asset class vault.\n     * @param controller Asset class controller.\n     */\n    struct ClassConfig {\n        address vault;\n        address controller;\n    }\n\n    /**\n     * @dev Registers new asset class.\n     * @param assetClass Asset class ID.\n     * @param config Asset class initial configuration.\n     */\n    function registerAssetClass(bytes4 assetClass, ClassConfig calldata config) external;\n\n    /**\n     * @dev Sets asset class vault.\n     * @param assetClass Asset class ID.\n     * @param vault Asset class vault address.\n     */\n    function setAssetClassVault(bytes4 assetClass, address vault) external;\n\n    /**\n     * @dev Sets asset class controller.\n     * @param assetClass Asset class ID.\n     * @param controller Asset class controller address.\n     */\n    function setAssetClassController(bytes4 assetClass, address controller) external;\n\n    /**\n     * @dev Returns asset class configuration.\n     * @param assetClass Asset class ID.\n     * @return Asset class configuration.\n     */\n    function assetClassConfig(bytes4 assetClass) external view returns (ClassConfig memory);\n\n    /**\n     * @dev Checks asset class registration.\n     * @param assetClass Asset class ID.\n     */\n    function isRegisteredAssetClass(bytes4 assetClass) external view returns (bool);\n\n    /**\n     * @dev Reverts if asset class is not registered.\n     * @param assetClass Asset class ID.\n     */\n    function checkRegisteredAssetClass(bytes4 assetClass) external view;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/listing/IListingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"./Listings.sol\";\nimport \"../renting/Rentings.sol\";\n\ninterface IListingController is IERC165 {\n    /**\n     * @dev Thrown when the listing strategy ID does not match the required one.\n     * @param provided Provided listing strategy ID.\n     * @param required Required listing strategy ID.\n     */\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Returns implemented strategy ID.\n     * @return Listing strategy ID.\n     */\n    function strategyId() external pure returns (bytes4);\n\n    /**\n     * @dev Calculates rental fee based on renting params and implemented listing strategy.\n     * @param listingParams Listing strategy params.\n     * @param rentingParams Renting params.\n     * @return Asset rental fee (base tokens per second).\n     */\n    function calculateRentalFee(Listings.Params calldata listingParams, Rentings.Params calldata rentingParams)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/listing/IListingStrategyRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Listings.sol\";\nimport \"./IListingController.sol\";\n\ninterface IListingStrategyRegistry {\n    /**\n     * @dev Thrown when listing controller does not implement the required interface.\n     */\n    error InvalidListingControllerInterface();\n\n    /**\n     * @dev Thrown when the listing cannot be processed by the specific controller due to the listing strategy ID\n     * mismatch.\n     * @param provided Provided listing strategy ID.\n     * @param required Required listing strategy ID.\n     */\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Thrown upon attempting to register a listing strategy twice.\n     * @param strategyId Duplicate listing strategy ID.\n     */\n    error ListingStrategyIsAlreadyRegistered(bytes4 strategyId);\n\n    /**\n     * @dev Thrown upon attempting to work with unregistered listing strategy.\n     * @param strategyId Listing strategy ID.\n     */\n    error UnregisteredListingStrategy(bytes4 strategyId);\n\n    /**\n     * @dev Emitted when the new listing strategy is registered.\n     * @param strategyId Listing strategy ID.\n     * @param controller Controller address.\n     */\n    event ListingStrategyRegistered(bytes4 indexed strategyId, address indexed controller);\n\n    /**\n     * @dev Emitted when the listing strategy controller is changed.\n     * @param strategyId Listing strategy ID.\n     * @param newController Controller address.\n     */\n    event ListingStrategyControllerChanged(bytes4 indexed strategyId, address indexed newController);\n\n    /**\n     * @dev Listing strategy information.\n     * @param controller Listing controller address.\n     */\n    struct StrategyConfig {\n        address controller;\n    }\n\n    /**\n     * @dev Registers new listing strategy.\n     * @param strategyId Listing strategy ID.\n     * @param config Listing strategy configuration.\n     */\n    function registerListingStrategy(bytes4 strategyId, StrategyConfig calldata config) external;\n\n    /**\n     * @dev Sets listing strategy controller.\n     * @param strategyId Listing strategy ID.\n     * @param controller Listing controller address.\n     */\n    function setListingController(bytes4 strategyId, address controller) external;\n\n    /**\n     * @dev Returns listing strategy configuration.\n     * @param strategyId Listing strategy ID.\n     * @return Listing strategy information.\n     */\n    function listingStrategy(bytes4 strategyId) external view returns (StrategyConfig memory);\n\n    /**\n     * @dev Returns listing strategy controller.\n     * @param strategyId Listing strategy ID.\n     * @return Listing controller address.\n     */\n    function listingController(bytes4 strategyId) external view returns (address);\n\n    /**\n     * @dev Checks listing strategy registration.\n     * @param strategyId Listing strategy ID.\n     */\n    function isRegisteredListingStrategy(bytes4 strategyId) external view returns (bool);\n\n    /**\n     * @dev Reverts if listing strategy is not registered.\n     * @param strategyId Listing strategy ID.\n     */\n    function checkRegisteredListingStrategy(bytes4 strategyId) external view;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165Upgradeable).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/IWarperController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../accounting/Accounts.sol\";\nimport \"../asset/Assets.sol\";\nimport \"../renting/Rentings.sol\";\nimport \"../asset/IAssetController.sol\";\nimport \"./IWarper.sol\";\n\ninterface IWarperController is IAssetController {\n    /**\n     * @dev Thrown if warper interface is not compatible with the controller.\n     */\n    error IncompatibleWarperInterface();\n\n    /**\n     * @dev Thrown upon attempting to use the warper with an asset different from the one expected by the warper.\n     */\n    error InvalidAssetForWarper(address warper, address asset);\n\n    /**\n     * @dev Thrown upon attempting to rent a warped asset which is already rented.\n     */\n    error AlreadyRented();\n\n    /**\n     * @dev Takes an existing asset and then mints a warper token representing it.\n     *      Used in Metahub->Warper communication.\n     * @param asset The asset that must be warped.\n     * @param warper Warper contract to used for warping.\n     * @param to The account which will receive the warped asset.\n     * @return warpedCollectionId Warped collection ID.\n     * @return warpedAsset Warper asset structure.\n     */\n    function warp(\n        Assets.Asset calldata asset,\n        address warper,\n        address to\n    ) external returns (bytes32 warpedCollectionId, Assets.Asset memory warpedAsset);\n\n    /**\n     * @dev Executes warper rental hook.\n     * @param rentalId Rental agreement ID.\n     * @param rentalAgreement Newly registered rental agreement details.\n     * @param rentalEarnings The rental earnings breakdown.\n     */\n    function executeRentingHooks(\n        uint256 rentalId,\n        Rentings.Agreement calldata rentalAgreement,\n        Accounts.RentalEarnings calldata rentalEarnings\n    ) external;\n\n    /**\n     * @dev Validates that the warper interface is supported by the current WarperController.\n     * @param warper Warper whose interface we must validate.\n     * @return bool - `true` if warper is supported.\n     */\n    function isCompatibleWarper(address warper) external view returns (bool);\n\n    /**\n     * @dev Reverts if provided warper is not compatible with the controller.\n     */\n    function checkCompatibleWarper(address warper) external view;\n\n    /**\n     * @dev Validates renting params taking into account various warper mechanics.\n     * Throws an error if the specified asset cannot be rented with particular renting parameters.\n     * @param asset Asset being rented.\n     * @param rentingParams Renting parameters.\n     */\n    function validateRentingParams(Assets.Asset calldata asset, Rentings.Params calldata rentingParams) external view;\n\n    /**\n     * @dev Calculates the universe and/or lister premiums.\n     * Those are extra amounts that should be added the the resulting rental fee paid by renter.\n     * @param asset Asset being rented.\n     * @param rentingParams Renting parameters.\n     * @param universeFee The current value of the universe fee component.\n     * @param listerFee The current value of the lister fee component.\n     * @return universePremium The universe premium amount.\n     * @return listerPremium The lister premium amount.\n     */\n    function calculatePremiums(\n        Assets.Asset calldata asset,\n        Rentings.Params calldata rentingParams,\n        uint256 universeFee,\n        uint256 listerFee\n    ) external view returns (uint256 universePremium, uint256 listerPremium);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/IWarperPresetFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IWarperPresetFactory {\n    /**\n     * @dev Thrown when the implementation does not support the IWarperPreset interface\n     */\n    error InvalidWarperPresetInterface();\n\n    /**\n     * @dev Thrown when the warper preset id is already present in the storage.\n     */\n    error DuplicateWarperPresetId(bytes32 presetId);\n\n    /**\n     * @dev Thrown when the warper preset has been disabled, when it was expected for it to be enabled.\n     */\n    error DisabledWarperPreset(bytes32 presetId);\n\n    /**\n     * @dev Thrown when the warper preset has been enabled, when it was expected for it to be disabled.\n     */\n    error EnabledWarperPreset(bytes32 presetId);\n\n    /**\n     * @dev Thrown when it was expected for the warper preset to be registeredr.\n     */\n    error WarperPresetNotRegistered(bytes32 presetId);\n\n    /**\n     * @dev Thrown when the provided preset initialization data is empty.\n     */\n    error EmptyPresetData();\n\n    struct WarperPreset {\n        bytes32 id;\n        address implementation;\n        bool enabled;\n    }\n\n    /**\n     * @dev Emitted when new warper preset is added.\n     */\n    event WarperPresetAdded(bytes32 indexed presetId, address indexed implementation);\n\n    /**\n     * @dev Emitted when a warper preset is disabled.\n     */\n    event WarperPresetDisabled(bytes32 indexed presetId);\n\n    /**\n     * @dev Emitted when a warper preset is enabled.\n     */\n    event WarperPresetEnabled(bytes32 indexed presetId);\n\n    /**\n     * @dev Emitted when a warper preset is enabled.\n     */\n    event WarperPresetRemoved(bytes32 indexed presetId);\n\n    /**\n     * @dev Emitted when a warper preset is deployed.\n     */\n    event WarperPresetDeployed(bytes32 indexed presetId, address indexed warper);\n\n    /**\n     * @dev Stores the association between `presetId` and `implementation` address.\n     * NOTE: Warper `implementation` must be deployed beforehand.\n     * @param presetId Warper preset id.\n     * @param implementation Warper implementation address.\n     */\n    function addPreset(bytes32 presetId, address implementation) external;\n\n    /**\n     * @dev Removes the association between `presetId` and its implementation.\n     * @param presetId Warper preset id.\n     */\n    function removePreset(bytes32 presetId) external;\n\n    /**\n     * @dev Enables warper preset, which makes it deployable.\n     * @param presetId Warper preset id.\n     */\n    function enablePreset(bytes32 presetId) external;\n\n    /**\n     * @dev Disable warper preset, which makes non-deployable.\n     * @param presetId Warper preset id.\n     */\n    function disablePreset(bytes32 presetId) external;\n\n    /**\n     * @dev Deploys a new warper from the preset identified by `presetId`.\n     * @param presetId Warper preset id.\n     * @param initData Warper initialization payload.\n     * @return Deployed warper address.\n     */\n    function deployPreset(bytes32 presetId, bytes calldata initData) external returns (address);\n\n    /**\n     * @dev Checks whether warper preset is enabled and available for deployment.\n     * @param presetId Warper preset id.\n     */\n    function presetEnabled(bytes32 presetId) external view returns (bool);\n\n    /**\n     * @dev Returns the list of all registered warper presets.\n     */\n    function presets() external view returns (WarperPreset[] memory);\n\n    /**\n     * @dev Returns the warper preset details.\n     * @param presetId Warper preset id.\n     */\n    function preset(bytes32 presetId) external view returns (WarperPreset memory);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/IWarperManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../asset/IAssetController.sol\";\nimport \"./Warpers.sol\";\n\ninterface IWarperManager {\n    /**\n     * @dev Warper registration params.\n     * @param name The warper name.\n     * @param universeId The universe ID.\n     * @param paused Indicates whether the warper should stay paused after registration.\n     */\n    struct WarperRegistrationParams {\n        string name;\n        uint256 universeId;\n        bool paused;\n    }\n\n    /**\n     * @dev Emitted when a new warper is registered.\n     * @param universeId Universe ID.\n     * @param warper Warper address.\n     * @param original Original asset address.\n     * @param assetClass Asset class ID (identical for the `original` and `warper`).\n     */\n    event WarperRegistered(\n        uint256 indexed universeId,\n        address indexed warper,\n        address indexed original,\n        bytes4 assetClass\n    );\n\n    /**\n     * @dev Emitted when the warper is no longer registered.\n     * @param warper Warper address.\n     */\n    event WarperDeregistered(address indexed warper);\n\n    /**\n     * @dev Emitted when the warper is paused.\n     * @param warper Address.\n     */\n    event WarperPaused(address indexed warper);\n\n    /**\n     * @dev Emitted when the warper pause is lifted.\n     * @param warper Address.\n     */\n    event WarperUnpaused(address indexed warper);\n\n    /**\n     * @dev Registers a new warper.\n     * The warper must be deployed and configured prior to registration,\n     * since it becomes available for renting immediately.\n     * @param warper Warper address.\n     * @param params Warper registration params.\n     */\n    function registerWarper(address warper, WarperRegistrationParams calldata params) external;\n\n    /**\n     * @dev Deletes warper registration information.\n     * All current rental agreements with the warper will stay intact, but the new rentals won't be possible.\n     * @param warper Warper address.\n     */\n    function deregisterWarper(address warper) external;\n\n    /**\n     * @dev Puts the warper on pause.\n     * Emits a {WarperPaused} event.\n     * @param warper Address.\n     */\n    function pauseWarper(address warper) external;\n\n    /**\n     * @dev Lifts the warper pause.\n     * Emits a {WarperUnpaused} event.\n     * @param warper Address.\n     */\n    function unpauseWarper(address warper) external;\n\n    /**\n     * @dev Sets the new controller address for one or multiple registered warpers.\n     * @param warpers A list of registered warper addresses which controller will be changed.\n     * @param controller Warper controller address.\n     */\n    function setWarperController(address[] calldata warpers, address controller) external;\n\n    /**\n     * @dev Reverts if asset is not supported.\n     * @param asset Asset address.\n     */\n    function checkSupportedAsset(address asset) external view;\n\n    /**\n     * @dev Reverts if warper is not registered.\n     */\n    function checkRegisteredWarper(address warper) external view;\n\n    /**\n     * @dev Returns the number of warpers belonging to the particular universe.\n     * @param universeId The universe ID.\n     * @return Warper count.\n     */\n    function universeWarperCount(uint256 universeId) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of warpers belonging to the particular universe.\n     * @param universeId The universe ID.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return List of warper addresses.\n     * @return List of warpers.\n     */\n    function universeWarpers(\n        uint256 universeId,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\n\n    /**\n     * @dev Returns the number of warpers associated with the particular original asset.\n     * @param original Original asset address.\n     * @return Warper count.\n     */\n    function assetWarperCount(address original) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of warpers associated with the particular original asset.\n     * @param original Original asset address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return List of warper addresses.\n     * @return List of warpers.\n     */\n    function assetWarpers(\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\n\n    /**\n     * @dev Returns warper preset factory address.\n     */\n    function warperPresetFactory() external view returns (address);\n\n    /**\n     * @dev Returns the Metahub address.\n     */\n    function metahub() external view returns (address);\n\n    /**\n     * @dev Checks whether `account` is the `warper` admin.\n     * @param warper Warper address.\n     * @param account Account address.\n     * @return True if the `account` is the admin of the `warper` and false otherwise.\n     */\n    function isWarperAdmin(address warper, address account) external view returns (bool);\n\n    /**\n     * @dev Returns registered warper details.\n     * @param warper Warper address.\n     * @return Warper details.\n     */\n    function warperInfo(address warper) external view returns (Warpers.Warper memory);\n\n    /**\n     * @dev Returns warper controller address.\n     * @param warper Warper address.\n     * @return Current controller.\n     */\n    function warperController(address warper) external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/IWarper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\ninterface IWarper is IERC165 {\n    /**\n     * @dev Returns the original asset address.\n     */\n    function __original() external view returns (address);\n\n    /**\n     * @dev Returns the Metahub address.\n     */\n    function __metahub() external view returns (address);\n\n    /**\n     * @dev Returns the warper asset class ID.\n     */\n    function __assetClass() external view returns (bytes4);\n\n    /**\n     * @dev Validates if a warper supports multiple interfaces at once.\n     * @return an array of `bool` flags in order as the `interfaceIds` were passed.\n     */\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/utils/CallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nabstract contract CallForwarder {\n    /**\n     * @dev Thrown when a call is forwarded to a zero address.\n     */\n    error CallForwardToZeroAddress();\n\n    /**\n     * @dev Forwards the current call to `target`.\n     */\n    function _forward(address target) internal {\n        // Prevent call forwarding to the zero address.\n        if (target == address(0)) {\n            revert CallForwardToZeroAddress();\n        }\n\n        uint256 value = msg.value;\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the target.\n            // out and outsize are 0 for now, as we don't know the out size yet.\n            let result := call(gas(), target, value, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // call returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/utils/WarperContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../metahub/IMetahub.sol\";\nimport \"./InitializationContext.sol\";\n\nabstract contract WarperContext is Context, InitializationContext {\n    /**\n     * @dev Thrown when the message sender doesn't match the Metahub address.\n     */\n    error CallerIsNotMetahub();\n\n    /**\n     * @dev Thrown when the message sender doesn't match the warper admin address.\n     */\n    error CallerIsNotWarperAdmin();\n\n    /**\n     * @dev Metahub address slot.\n     */\n    bytes32 private constant _METAHUB_SLOT = bytes32(uint256(keccak256(\"iq.warper.metahub\")) - 1);\n\n    /**\n     * @dev Original asset address slot.\n     */\n    bytes32 private constant _ORIGINAL_SLOT = bytes32(uint256(keccak256(\"iq.warper.original\")) - 1);\n\n    /**\n     * @dev Modifier to make a function callable only by the metahub contract.\n     */\n    modifier onlyMetahub() {\n        if (_msgSender() != _metahub()) {\n            revert CallerIsNotMetahub();\n        }\n        _;\n    }\n    /**\n     * @dev Modifier to make a function callable only by the warper admin.\n     */\n    modifier onlyWarperAdmin() {\n        if (!IMetahub(_metahub()).isWarperAdmin(address(this), _msgSender())) {\n            revert CallerIsNotWarperAdmin();\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets warper original asset address.\n     */\n    function _setOriginal(address original) internal onlyInitializingWarper {\n        StorageSlot.getAddressSlot(_ORIGINAL_SLOT).value = original;\n    }\n\n    /**\n     * @dev Sets warper metahub address.\n     */\n    function _setMetahub(address metahub) internal onlyInitializingWarper {\n        StorageSlot.getAddressSlot(_METAHUB_SLOT).value = metahub;\n    }\n\n    /**\n     * @dev Returns warper original asset address.\n     */\n    function _original() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ORIGINAL_SLOT).value;\n    }\n\n    /**\n     * @dev warper metahub address.\n     */\n    function _metahub() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_METAHUB_SLOT).value;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/utils/InitializationContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract InitializationContext {\n    /**\n     * @dev Thrown upon attempt to initialize a contract again.\n     */\n    error ContractIsAlreadyInitialized();\n\n    /**\n     * @dev Thrown when a function is invoked outside of initialization transaction.\n     */\n    error ContractIsNotInitializing();\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bytes32 internal constant _INITIALIZED_SLOT = bytes32(uint256(keccak256(\"iq.context.initialized\")) - 1);\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bytes32 internal constant _INITIALIZING_SLOT = bytes32(uint256(keccak256(\"iq.context.initializing\")) - 1);\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier warperInitializer() {\n        bool initialized = !(\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value\n                ? _isConstructor()\n                : !StorageSlot.getBooleanSlot(_INITIALIZED_SLOT).value\n        );\n\n        if (initialized) {\n            revert ContractIsAlreadyInitialized();\n        }\n\n        bool isTopLevelCall = !StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value;\n        if (isTopLevelCall) {\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value = true;\n            StorageSlot.getBooleanSlot(_INITIALIZED_SLOT).value = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializingWarper() {\n        if (!StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value) {\n            revert ContractIsNotInitializing();\n        }\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/mechanics/availability-period/IConfigurableAvailabilityPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"./IAvailabilityPeriodMechanics.sol\";\n\ninterface IConfigurableAvailabilityPeriodExtension is IAvailabilityPeriodMechanics {\n    /**\n     * @dev Thrown when the availability period start time is not strictly lesser than the end time\n     */\n    error InvalidAvailabilityPeriodStart();\n\n    /**\n     * @dev Thrown when the availability period end time is not greater or equal than the start time\n     */\n    error InvalidAvailabilityPeriodEnd();\n\n    /**\n     * @dev Sets warper availability period starting time.\n     * @param availabilityPeriodStart Unix timestamp after which the warper is rentable.\n     */\n    function __setAvailabilityPeriodStart(uint32 availabilityPeriodStart) external;\n\n    /**\n     * @dev Sets warper availability period ending time.\n     * @param availabilityPeriodEnd Unix timestamp after which the warper is NOT rentable.\n     */\n    function __setAvailabilityPeriodEnd(uint32 availabilityPeriodEnd) external;\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/mechanics/availability-period/IAvailabilityPeriodMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\ninterface IAvailabilityPeriodMechanics {\n    /**\n     * @dev Thrown when the current time is not withing the warper availability period.\n     */\n    error WarperIsNotAvailableForRenting(\n        uint256 currentTime,\n        uint32 availabilityPeriodStart,\n        uint32 availabilityPeriodEnd\n    );\n\n    /**\n     * @dev Returns warper availability period starting time.\n     * @return Unix timestamp after which the warper is rentable.\n     */\n    function __availabilityPeriodStart() external view returns (uint32);\n\n    /**\n     * @dev Returns warper availability period ending time.\n     * @return Unix timestamp after which the warper is NOT rentable.\n     */\n    function __availabilityPeriodEnd() external view returns (uint32);\n\n    /**\n     * @dev Returns warper availability period.\n     * @return availabilityPeriodStart Unix timestamp after which the warper is rentable.\n     * @return availabilityPeriodEnd Unix timestamp after which the warper is NOT rentable.\n     */\n    function __availabilityPeriodRange()\n        external\n        view\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd);\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/mechanics/rental-period/IConfigurableRentalPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"./IRentalPeriodMechanics.sol\";\n\ninterface IConfigurableRentalPeriodExtension is IRentalPeriodMechanics {\n    /**\n     * @dev Thrown when the the min rental period is not strictly lesser than max rental period\n     */\n    error InvalidMinRentalPeriod();\n\n    /**\n     * @dev Thrown when the max rental period is not greater or equal than min rental period\n     */\n    error InvalidMaxRentalPeriod();\n\n    /**\n     * @dev Sets warper min rental period.\n     * @param minRentalPeriod New min rental period value.\n     */\n    function __setMinRentalPeriod(uint32 minRentalPeriod) external;\n\n    /**\n     * @dev Sets warper max rental period.\n     * @param maxRentalPeriod New max rental period value.\n     */\n    function __setMaxRentalPeriod(uint32 maxRentalPeriod) external;\n}\n"
    },
    "@iqprotocol/solidity-contracts-nft/contracts/warper/mechanics/rental-period/IRentalPeriodMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\ninterface IRentalPeriodMechanics {\n    /**\n     * @dev Thrown when the requested rental period is not withing the warper allowed rental period range.\n     */\n    error WarperRentalPeriodIsOutOfRange(uint32 requestedRentalPeriod, uint32 minRentalPeriod, uint32 maxRentalPeriod);\n\n    /**\n     * @dev Returns warper minimal rental period.\n     * @return Time is seconds.\n     */\n    function __minRentalPeriod() external view returns (uint32);\n\n    /**\n     * @dev Returns warper maximal rental period.\n     * @return Time is seconds.\n     */\n    function __maxRentalPeriod() external view returns (uint32);\n\n    /**\n     * @dev Returns warper rental period range.\n     * @return minRentalPeriod The minimal amount of time the warper can be rented for.\n     * @return maxRentalPeriod The maximal amount of time the warper can be rented for.\n     */\n    function __rentalPeriodRange() external view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod);\n}\n"
    },
    "contracts/mocks/IQProtocolStructsMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@iqprotocol/solidity-contracts-nft/contracts/asset/Assets.sol\";\n\nlibrary IQProtocolStructsMock {\n    /**\n     * @dev Rental agreement information.\n     * @param warpedAssets Rented asset(s).\n     * @param universeId The Universe ID.\n     * @param collectionId Warped collection ID.\n     * @param listingId The corresponding ID of the original asset(s) listing.\n     * @param renter The renter account address.\n     * @param startTime The rental agreement staring time. This is the timestamp after which the `renter`\n     * considered to be an warped asset(s) owner.\n     * @param endTime The rental agreement ending time. After this timestamp, the rental agreement is terminated\n     * and the `renter` is no longer the owner of the warped asset(s).\n     * @param listingTerms Listing terms\n     */\n    struct Agreement {\n        Assets.Asset[] warpedAssets;\n        uint256 universeId;\n        bytes32 collectionId;\n        uint256 listingId;\n        address renter;\n        uint32 startTime;\n        uint32 endTime;\n        AgreementTerms agreementTerms;\n    }\n\n    struct AgreementTerms {\n        ListingTerms listingTerms;\n        TaxTerms universeTaxTerms;\n        TaxTerms protocolTaxTerms;\n        PaymentTokenData paymentTokenData;\n    }\n\n    /**\n     * @dev Listing terms information.\n     * @param strategyId Listing strategy ID.\n     * @param strategyData Listing strategy data.\n     */\n    struct ListingTerms {\n        bytes4 strategyId;\n        bytes strategyData;\n    }\n\n    /**\n     * @dev Tax terms information.\n     * @param strategyId Tax strategy ID.\n     * @param strategyData Tax strategy data.\n     */\n    struct TaxTerms {\n        bytes4 strategyId;\n        bytes strategyData;\n    }\n\n    /**\n     * @dev Describes the universe-specific token quote data.\n     * @param paymentToken Address of payment token.\n     * @param paymentTokenQuote Quote of payment token in accordance to base token\n     */\n    struct PaymentTokenData {\n        address paymentToken;\n        uint256 paymentTokenQuote;\n    }\n\n    /**\n     * @dev Describes the earning type.\n     */\n    enum EarningType {\n        LISTER_FIXED_FEE,\n        LISTER_EXTERNAL_ERC20_REWARD,\n        RENTER_EXTERNAL_ERC20_REWARD,\n        UNIVERSE_FIXED_FEE,\n        UNIVERSE_EXTERNAL_ERC20_REWARD,\n        PROTOCOL_FIXED_FEE,\n        PROTOCOL_EXTERNAL_ERC20_REWARD\n    }\n\n    /**\n     * @dev Describes the rent earning of user.\n     */\n    struct UserEarning {\n        EarningType earningType;\n        bool isLister;\n        address account;\n        uint256 value;\n        address token;\n    }\n\n    /**\n     * @dev Describes the rent earning of universe.\n     */\n    struct UniverseEarning {\n        EarningType earningType;\n        uint256 universeId;\n        uint256 value;\n        address token;\n    }\n\n    /**\n     * @dev Describes the rent earning of protocol.\n     */\n    struct ProtocolEarning {\n        EarningType earningType;\n        uint256 value;\n        address token;\n    }\n\n    /**\n     * @dev Describes the rent earnings of users , universe and protocol.\n     */\n    struct RentalEarnings {\n        UserEarning[] userEarnings;\n        UniverseEarning universeEarning;\n        ProtocolEarning protocolEarning;\n    }\n}\n"
    },
    "contracts/mocks/ERC20RewardDistributorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../interfaces/IERC20RewardDistributor.sol\";\n\ncontract ERC20RewardDistributorMock is IERC20RewardDistributor {\n    address internal _listingBeneficiary;\n    uint256 internal _listingBeneficiaryRewardAmount;\n    address internal _renter;\n    uint256 internal _renterRewardAmount;\n    uint256 internal _universeId;\n    uint256 internal _universeRewardAmount;\n    uint256 internal _protocolRewardAmount;\n\n    uint256 internal _listingId;\n    uint256 internal _agreementId;\n    uint256 internal _rewardAmount;\n\n    constructor(\n        address listingBeneficiary,\n        uint256 listingBeneficiaryRewardAmount,\n        address renter,\n        uint256 renterRewardAmount,\n        uint256 universeId,\n        uint256 universeRewardAmount,\n        uint256 protocolRewardAmount\n    ) {\n        _listingBeneficiary = listingBeneficiary;\n        _listingBeneficiaryRewardAmount = listingBeneficiaryRewardAmount;\n        _renter = renter;\n        _renterRewardAmount = renterRewardAmount;\n        _universeId = universeId;\n        _universeRewardAmount = universeRewardAmount;\n        _protocolRewardAmount = protocolRewardAmount;\n    }\n\n    /// @inheritdoc IERC20RewardDistributor\n    function distributeExternalReward(\n        uint256 listingId,\n        uint256 agreementId,\n        address token,\n        uint256 rewardAmount\n    ) external returns (IQProtocolStructsMock.RentalEarnings memory rentalExternalRewardEarnings) {\n        _listingId = listingId;\n        _agreementId = agreementId;\n        _rewardAmount = rewardAmount;\n\n        rentalExternalRewardEarnings.userEarnings = new IQProtocolStructsMock.UserEarning[](2);\n\n        rentalExternalRewardEarnings.userEarnings[0] = IQProtocolStructsMock.UserEarning({\n            earningType: IQProtocolStructsMock.EarningType.LISTER_EXTERNAL_ERC20_REWARD,\n            isLister: true,\n            account: _listingBeneficiary,\n            value: _listingBeneficiaryRewardAmount,\n            token: token\n        });\n\n        rentalExternalRewardEarnings.userEarnings[1] = IQProtocolStructsMock.UserEarning({\n            earningType: IQProtocolStructsMock.EarningType.RENTER_EXTERNAL_ERC20_REWARD,\n            isLister: false,\n            account: _renter,\n            value: _renterRewardAmount,\n            token: token\n        });\n\n        rentalExternalRewardEarnings.universeEarning = IQProtocolStructsMock.UniverseEarning({\n            earningType: IQProtocolStructsMock.EarningType.UNIVERSE_EXTERNAL_ERC20_REWARD,\n            universeId: _universeId,\n            value: _universeRewardAmount,\n            token: token\n        });\n\n        rentalExternalRewardEarnings.protocolEarning = IQProtocolStructsMock.ProtocolEarning({\n            earningType: IQProtocolStructsMock.EarningType.PROTOCOL_EXTERNAL_ERC20_REWARD,\n            value: _protocolRewardAmount,\n            token: token\n        });\n    }\n}\n"
    },
    "contracts/mocks/ContractRegistryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../interfaces/IContractRegistry.sol\";\n\ncontract ContractRegistryMock is IContractRegistry {\n    /**\n     * @dev Contract registry (contract key -> contract address).\n     */\n    mapping(bytes4 => address) internal _contractRegistry;\n\n    /**\n     * @inheritdoc IContractRegistry\n     */\n    function registerContract(bytes4 contractKey, address contractAddress) external {\n        _contractRegistry[contractKey] = contractAddress;\n    }\n\n    /**\n     * @inheritdoc IContractRegistry\n     */\n    function getContract(bytes4 contractKey) external view returns (address) {\n        return _contractRegistry[contractKey];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}